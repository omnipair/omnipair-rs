//! This code was AUTOGENERATED using the Codama library.
use juniper::{graphql_object, FieldResult};
use std::str::FromStr;

pub struct QueryRoot;

#[graphql_object(context = crate::graphql::context::GraphQLContext)]
impl QueryRoot {
    // Accounts
    async fn futarchy_authority(
        context: &crate::graphql::context::GraphQLContext,
        pubkey: String,
    ) -> FieldResult<Option<crate::accounts::graphql::FutarchyAuthorityGraphQL>> {
        use carbon_core::postgres::operations::LookUp;
        use carbon_core::postgres::primitives::Pubkey as PgPubkey;
        let pk = PgPubkey(solana_pubkey::Pubkey::from_str(&pubkey).map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?);
        let row = crate::accounts::postgres::FutarchyAuthorityRow::lookup(pk, &context.pool).await
            .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(row.map(|row| row.try_into().ok()).flatten())
    }

    async fn list_futarchy_authority(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::accounts::graphql::FutarchyAuthorityGraphQL>> {
        let rows: Vec<crate::accounts::postgres::FutarchyAuthorityRow> = sqlx::query_as(
            r#"SELECT * FROM futarchy_authority_account ORDER BY __slot DESC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn pair(
        context: &crate::graphql::context::GraphQLContext,
        pubkey: String,
    ) -> FieldResult<Option<crate::accounts::graphql::PairGraphQL>> {
        use carbon_core::postgres::operations::LookUp;
        use carbon_core::postgres::primitives::Pubkey as PgPubkey;
        let pk = PgPubkey(solana_pubkey::Pubkey::from_str(&pubkey).map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?);
        let row = crate::accounts::postgres::PairRow::lookup(pk, &context.pool).await
            .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(row.map(|row| row.try_into().ok()).flatten())
    }

    async fn list_pair(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::accounts::graphql::PairGraphQL>> {
        let rows: Vec<crate::accounts::postgres::PairRow> = sqlx::query_as(
            r#"SELECT * FROM pair_account ORDER BY __slot DESC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn rate_model(
        context: &crate::graphql::context::GraphQLContext,
        pubkey: String,
    ) -> FieldResult<Option<crate::accounts::graphql::RateModelGraphQL>> {
        use carbon_core::postgres::operations::LookUp;
        use carbon_core::postgres::primitives::Pubkey as PgPubkey;
        let pk = PgPubkey(solana_pubkey::Pubkey::from_str(&pubkey).map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?);
        let row = crate::accounts::postgres::RateModelRow::lookup(pk, &context.pool).await
            .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(row.map(|row| row.try_into().ok()).flatten())
    }

    async fn list_rate_model(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::accounts::graphql::RateModelGraphQL>> {
        let rows: Vec<crate::accounts::postgres::RateModelRow> = sqlx::query_as(
            r#"SELECT * FROM rate_model_account ORDER BY __slot DESC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn user_position(
        context: &crate::graphql::context::GraphQLContext,
        pubkey: String,
    ) -> FieldResult<Option<crate::accounts::graphql::UserPositionGraphQL>> {
        use carbon_core::postgres::operations::LookUp;
        use carbon_core::postgres::primitives::Pubkey as PgPubkey;
        let pk = PgPubkey(solana_pubkey::Pubkey::from_str(&pubkey).map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?);
        let row = crate::accounts::postgres::UserPositionRow::lookup(pk, &context.pool).await
            .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(row.map(|row| row.try_into().ok()).flatten())
    }

    async fn list_user_position(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::accounts::graphql::UserPositionGraphQL>> {
        let rows: Vec<crate::accounts::postgres::UserPositionRow> = sqlx::query_as(
            r#"SELECT * FROM user_position_account ORDER BY __slot DESC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    // Instructions (per-instruction list and lookup by signature+index)
    async fn add_collateral(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::AddCollateralGraphQL>> {
        let rows: Vec<crate::instructions::postgres::AddCollateralRow> = sqlx::query_as(
            r#"SELECT * FROM add_collateral_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn list_add_collateral(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::AddCollateralGraphQL>> {
        let rows: Vec<crate::instructions::postgres::AddCollateralRow> = sqlx::query_as(
            r#"SELECT * FROM add_collateral_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn add_liquidity(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::AddLiquidityGraphQL>> {
        let rows: Vec<crate::instructions::postgres::AddLiquidityRow> = sqlx::query_as(
            r#"SELECT * FROM add_liquidity_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn list_add_liquidity(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::AddLiquidityGraphQL>> {
        let rows: Vec<crate::instructions::postgres::AddLiquidityRow> = sqlx::query_as(
            r#"SELECT * FROM add_liquidity_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn borrow(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::BorrowGraphQL>> {
        let rows: Vec<crate::instructions::postgres::BorrowRow> = sqlx::query_as(
            r#"SELECT * FROM borrow_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn list_borrow(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::BorrowGraphQL>> {
        let rows: Vec<crate::instructions::postgres::BorrowRow> = sqlx::query_as(
            r#"SELECT * FROM borrow_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn distribute_tokens(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::DistributeTokensGraphQL>> {
        let rows: Vec<crate::instructions::postgres::DistributeTokensRow> = sqlx::query_as(
            r#"SELECT * FROM distribute_tokens_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn list_distribute_tokens(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::DistributeTokensGraphQL>> {
        let rows: Vec<crate::instructions::postgres::DistributeTokensRow> = sqlx::query_as(
            r#"SELECT * FROM distribute_tokens_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn flashloan(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::FlashloanGraphQL>> {
        let rows: Vec<crate::instructions::postgres::FlashloanRow> = sqlx::query_as(
            r#"SELECT * FROM flashloan_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn list_flashloan(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::FlashloanGraphQL>> {
        let rows: Vec<crate::instructions::postgres::FlashloanRow> = sqlx::query_as(
            r#"SELECT * FROM flashloan_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn init_futarchy_authority(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::InitFutarchyAuthorityGraphQL>> {
        let rows: Vec<crate::instructions::postgres::InitFutarchyAuthorityRow> = sqlx::query_as(
            r#"SELECT * FROM init_futarchy_authority_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn list_init_futarchy_authority(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::InitFutarchyAuthorityGraphQL>> {
        let rows: Vec<crate::instructions::postgres::InitFutarchyAuthorityRow> = sqlx::query_as(
            r#"SELECT * FROM init_futarchy_authority_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn initialize(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::InitializeGraphQL>> {
        let rows: Vec<crate::instructions::postgres::InitializeRow> = sqlx::query_as(
            r#"SELECT * FROM initialize_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn list_initialize(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::InitializeGraphQL>> {
        let rows: Vec<crate::instructions::postgres::InitializeRow> = sqlx::query_as(
            r#"SELECT * FROM initialize_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn remove_collateral(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::RemoveCollateralGraphQL>> {
        let rows: Vec<crate::instructions::postgres::RemoveCollateralRow> = sqlx::query_as(
            r#"SELECT * FROM remove_collateral_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn list_remove_collateral(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::RemoveCollateralGraphQL>> {
        let rows: Vec<crate::instructions::postgres::RemoveCollateralRow> = sqlx::query_as(
            r#"SELECT * FROM remove_collateral_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn remove_liquidity(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::RemoveLiquidityGraphQL>> {
        let rows: Vec<crate::instructions::postgres::RemoveLiquidityRow> = sqlx::query_as(
            r#"SELECT * FROM remove_liquidity_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn list_remove_liquidity(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::RemoveLiquidityGraphQL>> {
        let rows: Vec<crate::instructions::postgres::RemoveLiquidityRow> = sqlx::query_as(
            r#"SELECT * FROM remove_liquidity_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn repay(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::RepayGraphQL>> {
        let rows: Vec<crate::instructions::postgres::RepayRow> = sqlx::query_as(
            r#"SELECT * FROM repay_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn list_repay(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::RepayGraphQL>> {
        let rows: Vec<crate::instructions::postgres::RepayRow> = sqlx::query_as(
            r#"SELECT * FROM repay_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn swap(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::SwapGraphQL>> {
        let rows: Vec<crate::instructions::postgres::SwapRow> = sqlx::query_as(
            r#"SELECT * FROM swap_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn list_swap(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::SwapGraphQL>> {
        let rows: Vec<crate::instructions::postgres::SwapRow> = sqlx::query_as(
            r#"SELECT * FROM swap_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn update_futarchy_authority(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::UpdateFutarchyAuthorityGraphQL>> {
        let rows: Vec<crate::instructions::postgres::UpdateFutarchyAuthorityRow> = sqlx::query_as(
            r#"SELECT * FROM update_futarchy_authority_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn list_update_futarchy_authority(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::UpdateFutarchyAuthorityGraphQL>> {
        let rows: Vec<crate::instructions::postgres::UpdateFutarchyAuthorityRow> = sqlx::query_as(
            r#"SELECT * FROM update_futarchy_authority_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn update_protocol_revenue(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::UpdateProtocolRevenueGraphQL>> {
        let rows: Vec<crate::instructions::postgres::UpdateProtocolRevenueRow> = sqlx::query_as(
            r#"SELECT * FROM update_protocol_revenue_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn list_update_protocol_revenue(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::UpdateProtocolRevenueGraphQL>> {
        let rows: Vec<crate::instructions::postgres::UpdateProtocolRevenueRow> = sqlx::query_as(
            r#"SELECT * FROM update_protocol_revenue_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn view_pair_data(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::ViewPairDataGraphQL>> {
        let rows: Vec<crate::instructions::postgres::ViewPairDataRow> = sqlx::query_as(
            r#"SELECT * FROM view_pair_data_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn list_view_pair_data(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::ViewPairDataGraphQL>> {
        let rows: Vec<crate::instructions::postgres::ViewPairDataRow> = sqlx::query_as(
            r#"SELECT * FROM view_pair_data_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn view_user_position_data(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::ViewUserPositionDataGraphQL>> {
        let rows: Vec<crate::instructions::postgres::ViewUserPositionDataRow> = sqlx::query_as(
            r#"SELECT * FROM view_user_position_data_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn list_view_user_position_data(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::ViewUserPositionDataGraphQL>> {
        let rows: Vec<crate::instructions::postgres::ViewUserPositionDataRow> = sqlx::query_as(
            r#"SELECT * FROM view_user_position_data_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn list_cpi_events(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::CpiEventGraphQL>> {
        let rows: Vec<crate::instructions::postgres::CpiEventRow> = sqlx::query_as(
            r#"SELECT * FROM cpi_events ORDER BY __slot DESC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }
}
