//! This code was AUTOGENERATED using the Codama library.
pub mod futarchy_authority_row;
pub mod pair_row;
pub mod rate_model_row;
pub mod user_position_row;

pub use self::futarchy_authority_row::*;
pub use self::pair_row::*;
pub use self::rate_model_row::*;
pub use self::user_position_row::*;

use super::OmnipairAccount;

pub struct OmnipairAccountsMigration;

impl sqlx_migrator::Migration<sqlx::Postgres> for OmnipairAccountsMigration {
    fn app(&self) -> &str {
        "omnipair"
    }

    fn name(&self) -> &str {
        "omnipair_accounts"
    }

    fn operations(&self) -> Vec<Box<dyn sqlx_migrator::Operation<sqlx::Postgres>>> {
        vec![
            Box::new(FutarchyAuthorityMigrationOperation),
            Box::new(PairMigrationOperation),
            Box::new(RateModelMigrationOperation),
            Box::new(UserPositionMigrationOperation),
        ]
    }

    fn parents(&self) -> Vec<Box<dyn sqlx_migrator::Migration<sqlx::Postgres>>> {
        vec![]
    }
}

pub struct OmnipairAccountWithMetadata(pub OmnipairAccount, pub carbon_core::account::AccountMetadata);

impl From<(OmnipairAccount, carbon_core::account::AccountMetadata)> for OmnipairAccountWithMetadata {
    fn from(value: (OmnipairAccount, carbon_core::account::AccountMetadata)) -> Self {
        OmnipairAccountWithMetadata(value.0, value.1)
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Insert for OmnipairAccountWithMetadata {
    async fn insert(&self, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        let OmnipairAccountWithMetadata(account, metadata) = self;

        match account {
            OmnipairAccount::FutarchyAuthority(account) => {
                let row = futarchy_authority_row::FutarchyAuthorityRow::from_parts(*account.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
            OmnipairAccount::Pair(account) => {
                let row = pair_row::PairRow::from_parts(*account.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
            OmnipairAccount::RateModel(account) => {
                let row = rate_model_row::RateModelRow::from_parts(*account.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
            OmnipairAccount::UserPosition(account) => {
                let row = user_position_row::UserPositionRow::from_parts(*account.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
        }
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Upsert for OmnipairAccountWithMetadata {
    async fn upsert(&self, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        let OmnipairAccountWithMetadata(account, metadata) = self;
        match account {
            OmnipairAccount::FutarchyAuthority(account) => {
                let row = futarchy_authority_row::FutarchyAuthorityRow::from_parts(*account.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
            OmnipairAccount::Pair(account) => {
                let row = pair_row::PairRow::from_parts(*account.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
            OmnipairAccount::RateModel(account) => {
                let row = rate_model_row::RateModelRow::from_parts(*account.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
            OmnipairAccount::UserPosition(account) => {
                let row = user_position_row::UserPositionRow::from_parts(*account.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
        }
    }
}

