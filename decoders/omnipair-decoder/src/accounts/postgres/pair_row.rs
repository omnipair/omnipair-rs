//! This code was AUTOGENERATED using the Codama library.
use carbon_core::account::AccountMetadata;
use carbon_core::postgres::metadata::AccountRowMetadata;
use carbon_core::postgres::primitives::Pubkey;
use carbon_core::postgres::primitives::U128;
use carbon_core::postgres::primitives::U16;
use carbon_core::postgres::primitives::U64;
use carbon_core::postgres::primitives::U8;
use crate::types::LastPriceEMA;
use crate::types::VaultBumps;

#[derive(sqlx::FromRow, Debug, Clone)]
pub struct PairRow {
    #[sqlx(flatten)]
    pub account_metadata: AccountRowMetadata,
    pub token0: Pubkey,
    pub token1: Pubkey,
    pub lp_mint: Pubkey,
    pub rate_model: Pubkey,
    pub swap_fee_bps: U16,
    pub half_life: U64,
    pub fixed_cf_bps: Option<U16>,
    pub reserve0: U64,
    pub reserve1: U64,
    pub cash_reserve0: U64,
    pub cash_reserve1: U64,
    pub last_price0_ema: sqlx::types::Json<LastPriceEMA>,
    pub last_price1_ema: sqlx::types::Json<LastPriceEMA>,
    pub last_update: U64,
    pub last_rate0: U64,
    pub last_rate1: U64,
    pub total_debt0: U64,
    pub total_debt1: U64,
    pub total_debt0_shares: U128,
    pub total_debt1_shares: U128,
    pub total_supply: U64,
    pub total_collateral0: U64,
    pub total_collateral1: U64,
    pub token0_decimals: U8,
    pub token1_decimals: U8,
    pub params_hash: Vec<u8>,
    pub version: U8,
    pub bump: U8,
    pub vault_bumps: sqlx::types::Json<VaultBumps>,
}

impl PairRow {
    pub fn from_parts(source: crate::accounts::pair::Pair, metadata: AccountMetadata) -> Self {
        Self {
            account_metadata: metadata.into(),
            token0: source.token0.into(),
            token1: source.token1.into(),
            lp_mint: source.lp_mint.into(),
            rate_model: source.rate_model.into(),
            swap_fee_bps: source.swap_fee_bps.into(),
            half_life: source.half_life.into(),
            fixed_cf_bps: source.fixed_cf_bps.map(|value| value.into()),
            reserve0: source.reserve0.into(),
            reserve1: source.reserve1.into(),
            cash_reserve0: source.cash_reserve0.into(),
            cash_reserve1: source.cash_reserve1.into(),
            last_price0_ema: sqlx::types::Json(source.last_price0_ema.into()),
            last_price1_ema: sqlx::types::Json(source.last_price1_ema.into()),
            last_update: source.last_update.into(),
            last_rate0: source.last_rate0.into(),
            last_rate1: source.last_rate1.into(),
            total_debt0: source.total_debt0.into(),
            total_debt1: source.total_debt1.into(),
            total_debt0_shares: source.total_debt0_shares.into(),
            total_debt1_shares: source.total_debt1_shares.into(),
            total_supply: source.total_supply.into(),
            total_collateral0: source.total_collateral0.into(),
            total_collateral1: source.total_collateral1.into(),
            token0_decimals: source.token0_decimals.into(),
            token1_decimals: source.token1_decimals.into(),
            params_hash: source.params_hash.to_vec(),
            version: source.version.into(),
            bump: source.bump.into(),
            vault_bumps: sqlx::types::Json(source.vault_bumps.into()),
        }
    }
}

impl TryFrom<PairRow> for crate::accounts::pair::Pair {
    type Error = carbon_core::error::Error;
    fn try_from(source: PairRow) -> Result<Self, Self::Error> {
        Ok(Self {
            token0: *source.token0,
            token1: *source.token1,
            lp_mint: *source.lp_mint,
            rate_model: *source.rate_model,
            swap_fee_bps: source.swap_fee_bps.try_into().map_err(|_| carbon_core::error::Error::Custom("Failed to convert value from postgres primitive".to_string()))?,
            half_life: *source.half_life,
            fixed_cf_bps: source.fixed_cf_bps.map(|value| value.try_into().map_err(|_| carbon_core::error::Error::Custom("Failed to convert value from postgres primitive".to_string()))).transpose()?,
            reserve0: *source.reserve0,
            reserve1: *source.reserve1,
            cash_reserve0: *source.cash_reserve0,
            cash_reserve1: *source.cash_reserve1,
            last_price0_ema: source.last_price0_ema.0,
            last_price1_ema: source.last_price1_ema.0,
            last_update: *source.last_update,
            last_rate0: *source.last_rate0,
            last_rate1: *source.last_rate1,
            total_debt0: *source.total_debt0,
            total_debt1: *source.total_debt1,
            total_debt0_shares: *source.total_debt0_shares,
            total_debt1_shares: *source.total_debt1_shares,
            total_supply: *source.total_supply,
            total_collateral0: *source.total_collateral0,
            total_collateral1: *source.total_collateral1,
            token0_decimals: source.token0_decimals.try_into().map_err(|_| carbon_core::error::Error::Custom("Failed to convert value from postgres primitive".to_string()))?,
            token1_decimals: source.token1_decimals.try_into().map_err(|_| carbon_core::error::Error::Custom("Failed to convert value from postgres primitive".to_string()))?,
            params_hash: source.params_hash.as_slice().try_into().map_err(|_| carbon_core::error::Error::Custom("Failed to convert padding from postgres primitive: expected 32 bytes".to_string()))?,
            version: source.version.try_into().map_err(|_| carbon_core::error::Error::Custom("Failed to convert value from postgres primitive".to_string()))?,
            bump: source.bump.try_into().map_err(|_| carbon_core::error::Error::Custom("Failed to convert value from postgres primitive".to_string()))?,
            vault_bumps: source.vault_bumps.0,
        })
    }
}

impl carbon_core::postgres::operations::Table for crate::accounts::pair::Pair {
    fn table() -> &'static str {
        "pair_account"
    }

    fn columns() -> Vec<&'static str> {
        vec![
            "__pubkey",
            "__slot",
            "token0",
            "token1",
            "lp_mint",
            "rate_model",
            "swap_fee_bps",
            "half_life",
            "fixed_cf_bps",
            "reserve0",
            "reserve1",
            "cash_reserve0",
            "cash_reserve1",
            "last_price0_ema",
            "last_price1_ema",
            "last_update",
            "last_rate0",
            "last_rate1",
            "total_debt0",
            "total_debt1",
            "total_debt0_shares",
            "total_debt1_shares",
            "total_supply",
            "total_collateral0",
            "total_collateral1",
            "token0_decimals",
            "token1_decimals",
            "params_hash",
            "version",
            "bump",
            "vault_bumps",
        ]
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Insert for PairRow {
    async fn insert(&self, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        sqlx::query(r#"
            INSERT INTO pair_account (
                "token0",
                "token1",
                "lp_mint",
                "rate_model",
                "swap_fee_bps",
                "half_life",
                "fixed_cf_bps",
                "reserve0",
                "reserve1",
                "cash_reserve0",
                "cash_reserve1",
                "last_price0_ema",
                "last_price1_ema",
                "last_update",
                "last_rate0",
                "last_rate1",
                "total_debt0",
                "total_debt1",
                "total_debt0_shares",
                "total_debt1_shares",
                "total_supply",
                "total_collateral0",
                "total_collateral1",
                "token0_decimals",
                "token1_decimals",
                "params_hash",
                "version",
                "bump",
                "vault_bumps",
                __pubkey, __slot
            ) VALUES (
                $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31
            )"#)
        .bind(self.token0.clone())
        .bind(self.token1.clone())
        .bind(self.lp_mint.clone())
        .bind(self.rate_model.clone())
        .bind(self.swap_fee_bps.clone())
        .bind(self.half_life.clone())
        .bind(self.fixed_cf_bps.clone())
        .bind(self.reserve0.clone())
        .bind(self.reserve1.clone())
        .bind(self.cash_reserve0.clone())
        .bind(self.cash_reserve1.clone())
        .bind(self.last_price0_ema.clone())
        .bind(self.last_price1_ema.clone())
        .bind(self.last_update.clone())
        .bind(self.last_rate0.clone())
        .bind(self.last_rate1.clone())
        .bind(self.total_debt0.clone())
        .bind(self.total_debt1.clone())
        .bind(self.total_debt0_shares.clone())
        .bind(self.total_debt1_shares.clone())
        .bind(self.total_supply.clone())
        .bind(self.total_collateral0.clone())
        .bind(self.total_collateral1.clone())
        .bind(self.token0_decimals.clone())
        .bind(self.token1_decimals.clone())
        .bind(self.params_hash.clone())
        .bind(self.version.clone())
        .bind(self.bump.clone())
        .bind(self.vault_bumps.clone())
        .bind(self.account_metadata.pubkey.clone())
        .bind(self.account_metadata.slot.clone())
        .execute(pool).await
        .map_err(|e| carbon_core::error::Error::Custom(e.to_string()))?;
        Ok(())
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Upsert for PairRow {
    async fn upsert(&self, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        sqlx::query(r#"INSERT INTO pair_account (
                "token0",
                "token1",
                "lp_mint",
                "rate_model",
                "swap_fee_bps",
                "half_life",
                "fixed_cf_bps",
                "reserve0",
                "reserve1",
                "cash_reserve0",
                "cash_reserve1",
                "last_price0_ema",
                "last_price1_ema",
                "last_update",
                "last_rate0",
                "last_rate1",
                "total_debt0",
                "total_debt1",
                "total_debt0_shares",
                "total_debt1_shares",
                "total_supply",
                "total_collateral0",
                "total_collateral1",
                "token0_decimals",
                "token1_decimals",
                "params_hash",
                "version",
                "bump",
                "vault_bumps",
                __pubkey, __slot
            ) VALUES (
                $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31
            ) ON CONFLICT (
                __pubkey
            ) DO UPDATE SET
                "token0" = EXCLUDED."token0",
                "token1" = EXCLUDED."token1",
                "lp_mint" = EXCLUDED."lp_mint",
                "rate_model" = EXCLUDED."rate_model",
                "swap_fee_bps" = EXCLUDED."swap_fee_bps",
                "half_life" = EXCLUDED."half_life",
                "fixed_cf_bps" = EXCLUDED."fixed_cf_bps",
                "reserve0" = EXCLUDED."reserve0",
                "reserve1" = EXCLUDED."reserve1",
                "cash_reserve0" = EXCLUDED."cash_reserve0",
                "cash_reserve1" = EXCLUDED."cash_reserve1",
                "last_price0_ema" = EXCLUDED."last_price0_ema",
                "last_price1_ema" = EXCLUDED."last_price1_ema",
                "last_update" = EXCLUDED."last_update",
                "last_rate0" = EXCLUDED."last_rate0",
                "last_rate1" = EXCLUDED."last_rate1",
                "total_debt0" = EXCLUDED."total_debt0",
                "total_debt1" = EXCLUDED."total_debt1",
                "total_debt0_shares" = EXCLUDED."total_debt0_shares",
                "total_debt1_shares" = EXCLUDED."total_debt1_shares",
                "total_supply" = EXCLUDED."total_supply",
                "total_collateral0" = EXCLUDED."total_collateral0",
                "total_collateral1" = EXCLUDED."total_collateral1",
                "token0_decimals" = EXCLUDED."token0_decimals",
                "token1_decimals" = EXCLUDED."token1_decimals",
                "params_hash" = EXCLUDED."params_hash",
                "version" = EXCLUDED."version",
                "bump" = EXCLUDED."bump",
                "vault_bumps" = EXCLUDED."vault_bumps",
                __slot = EXCLUDED.__slot
            "#)
        .bind(self.token0.clone())
        .bind(self.token1.clone())
        .bind(self.lp_mint.clone())
        .bind(self.rate_model.clone())
        .bind(self.swap_fee_bps.clone())
        .bind(self.half_life.clone())
        .bind(self.fixed_cf_bps.clone())
        .bind(self.reserve0.clone())
        .bind(self.reserve1.clone())
        .bind(self.cash_reserve0.clone())
        .bind(self.cash_reserve1.clone())
        .bind(self.last_price0_ema.clone())
        .bind(self.last_price1_ema.clone())
        .bind(self.last_update.clone())
        .bind(self.last_rate0.clone())
        .bind(self.last_rate1.clone())
        .bind(self.total_debt0.clone())
        .bind(self.total_debt1.clone())
        .bind(self.total_debt0_shares.clone())
        .bind(self.total_debt1_shares.clone())
        .bind(self.total_supply.clone())
        .bind(self.total_collateral0.clone())
        .bind(self.total_collateral1.clone())
        .bind(self.token0_decimals.clone())
        .bind(self.token1_decimals.clone())
        .bind(self.params_hash.clone())
        .bind(self.version.clone())
        .bind(self.bump.clone())
        .bind(self.vault_bumps.clone())
        .bind(self.account_metadata.pubkey)
        .bind(self.account_metadata.slot.clone())
        .execute(pool).await
        .map_err(|e| carbon_core::error::Error::Custom(e.to_string()))?;
        Ok(())
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Delete for PairRow {
    type Key = carbon_core::postgres::primitives::Pubkey;

    async fn delete(key: Self::Key, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        sqlx::query(r#"DELETE FROM pair_account WHERE
                __pubkey = $1
            "#)
        .bind(key)
        .execute(pool).await
        .map_err(|e| carbon_core::error::Error::Custom(e.to_string()))?;
        Ok(())
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::LookUp for PairRow {
    type Key = carbon_core::postgres::primitives::Pubkey;

    async fn lookup(key: Self::Key, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<Option<Self>> {
        let row = sqlx::query_as(r#"SELECT * FROM pair_account WHERE
                __pubkey = $1
            "#)
        .bind(key)
        .fetch_optional(pool).await
        .map_err(|e| carbon_core::error::Error::Custom(e.to_string()))?;
        Ok(row)
    }
}

pub struct PairMigrationOperation;

#[async_trait::async_trait]
impl sqlx_migrator::Operation<sqlx::Postgres> for PairMigrationOperation {
    async fn up(&self, connection: &mut sqlx::PgConnection) -> Result<(), sqlx_migrator::error::Error> {
        sqlx::query(r#"CREATE TABLE IF NOT EXISTS pair_account (
                -- Account data
                "token0" BYTEA NOT NULL,
                "token1" BYTEA NOT NULL,
                "lp_mint" BYTEA NOT NULL,
                "rate_model" BYTEA NOT NULL,
                "swap_fee_bps" INT4 NOT NULL,
                "half_life" NUMERIC(20) NOT NULL,
                "fixed_cf_bps" INT4,
                "reserve0" NUMERIC(20) NOT NULL,
                "reserve1" NUMERIC(20) NOT NULL,
                "cash_reserve0" NUMERIC(20) NOT NULL,
                "cash_reserve1" NUMERIC(20) NOT NULL,
                "last_price0_ema" JSONB NOT NULL,
                "last_price1_ema" JSONB NOT NULL,
                "last_update" NUMERIC(20) NOT NULL,
                "last_rate0" NUMERIC(20) NOT NULL,
                "last_rate1" NUMERIC(20) NOT NULL,
                "total_debt0" NUMERIC(20) NOT NULL,
                "total_debt1" NUMERIC(20) NOT NULL,
                "total_debt0_shares" NUMERIC(39) NOT NULL,
                "total_debt1_shares" NUMERIC(39) NOT NULL,
                "total_supply" NUMERIC(20) NOT NULL,
                "total_collateral0" NUMERIC(20) NOT NULL,
                "total_collateral1" NUMERIC(20) NOT NULL,
                "token0_decimals" INT2 NOT NULL,
                "token1_decimals" INT2 NOT NULL,
                "params_hash" BYTEA NOT NULL,
                "version" INT2 NOT NULL,
                "bump" INT2 NOT NULL,
                "vault_bumps" JSONB NOT NULL,
                -- Account metadata
                __pubkey BYTEA NOT NULL,
                __slot NUMERIC(20),
                PRIMARY KEY (__pubkey)
            )"#).execute(connection).await?;
        Ok(())
    }

    async fn down(&self, connection: &mut sqlx::PgConnection) -> Result<(), sqlx_migrator::error::Error> {
        sqlx::query(r#"DROP TABLE IF EXISTS pair_account"#).execute(connection).await?;
        Ok(())
    }
}
