//! # Trident Generated Types
//!
//! This file is automatically generated by Trident.
//! **DO NOT EDIT THIS FILE MANUALLY**

#![allow(dead_code)]
#![allow(unused_imports)]

use borsh::BorshDeserialize;
use borsh::BorshSerialize;
use trident_fuzz::fuzzing::*;

// ============================================================================
// PROGRAM MODULES
// ============================================================================

// ----------------------------------------------------------------------------
// Program: faucet
// ----------------------------------------------------------------------------
pub mod faucet {
    use super::*;

    // ------------------------------------------------------------------------
    // Program ID
    // ------------------------------------------------------------------------

    /// Returns the program ID for faucet
    pub fn program_id() -> Pubkey {
        pubkey!("3Ckfn1LMByoDfVpcDPf7nouk5nQAUm51Zkdf1oprQTAK")
    }

    // ------------------------------------------------------------------------
    // Instructions
    // ------------------------------------------------------------------------

    // ....................................................................
    // Instruction: FaucetMint
    // ....................................................................

    /// Main instruction struct for FaucetMint
    pub struct FaucetMintInstruction {
        pub accounts: FaucetMintInstructionAccountMetas,
        pub data: FaucetMintInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for FaucetMint instruction
    #[derive(Debug, Clone, Default)]
    pub struct FaucetMintInstructionAccountMetas {
        pub user: AccountMeta,

        pub faucet_authority: AccountMeta,

        pub user_token0_account: AccountMeta,

        pub user_token1_account: AccountMeta,

        pub token0_mint: AccountMeta,

        pub token1_mint: AccountMeta,

        pub system_program: AccountMeta,

        pub token_program: AccountMeta,

        pub associated_token_program: AccountMeta,
    }

    /// Account pubkeys for FaucetMint instruction
    #[derive(Debug, Clone)]
    pub struct FaucetMintInstructionAccounts {
        pub user: Pubkey,

        pub faucet_authority: Pubkey,

        pub user_token0_account: Pubkey,

        pub user_token1_account: Pubkey,

        pub token0_mint: Pubkey,

        pub token1_mint: Pubkey,
    }

    impl FaucetMintInstructionAccounts {
        pub fn new(
            user: Pubkey,

            faucet_authority: Pubkey,

            user_token0_account: Pubkey,

            user_token1_account: Pubkey,

            token0_mint: Pubkey,

            token1_mint: Pubkey,
        ) -> Self {
            Self {
                user,

                faucet_authority,

                user_token0_account,

                user_token1_account,

                token0_mint,

                token1_mint,
            }
        }
    }

    /// Instruction data for FaucetMint
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct FaucetMintInstructionData {}

    impl FaucetMintInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for FaucetMintInstruction
    impl FaucetMintInstruction {
        fn discriminator() -> [u8; 8] {
            [47u8, 229u8, 221u8, 88u8, 0u8, 56u8, 156u8, 38u8]
        }

        pub fn data(data: FaucetMintInstructionData) -> Self {
            Self {
                accounts: FaucetMintInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: FaucetMintInstructionAccounts) -> Self {
            self.accounts.user = AccountMeta::new(accounts.user, true);

            self.accounts.faucet_authority =
                AccountMeta::new_readonly(accounts.faucet_authority, false);

            self.accounts.user_token0_account =
                AccountMeta::new(accounts.user_token0_account, false);

            self.accounts.user_token1_account =
                AccountMeta::new(accounts.user_token1_account, false);

            self.accounts.token0_mint = AccountMeta::new(accounts.token0_mint, false);

            self.accounts.token1_mint = AccountMeta::new(accounts.token1_mint, false);

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self.accounts.token_program = AccountMeta::new_readonly(
                pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
                false,
            );

            self.accounts.associated_token_program = AccountMeta::new_readonly(
                pubkey!("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"),
                false,
            );

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.user.clone());

            metas.push(self.accounts.faucet_authority.clone());

            metas.push(self.accounts.user_token0_account.clone());

            metas.push(self.accounts.user_token1_account.clone());

            metas.push(self.accounts.token0_mint.clone());

            metas.push(self.accounts.token1_mint.clone());

            metas.push(self.accounts.system_program.clone());

            metas.push(self.accounts.token_program.clone());

            metas.push(self.accounts.associated_token_program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ------------------------------------------------------------------------
    // Composite Accounts
    // ------------------------------------------------------------------------
}

// ----------------------------------------------------------------------------
// Program: omnipair
// ----------------------------------------------------------------------------
pub mod omnipair {
    use super::*;

    // ------------------------------------------------------------------------
    // Program ID
    // ------------------------------------------------------------------------

    /// Returns the program ID for omnipair
    pub fn program_id() -> Pubkey {
        pubkey!("Bd9Uhf5S8yzfop8cG9oqRs6jVcLtu8B4cb2gvRmtbNzk")
    }

    // ------------------------------------------------------------------------
    // Instructions
    // ------------------------------------------------------------------------

    // ....................................................................
    // Instruction: AddCollateral
    // ....................................................................

    /// Main instruction struct for AddCollateral
    pub struct AddCollateralInstruction {
        pub accounts: AddCollateralInstructionAccountMetas,
        pub data: AddCollateralInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for AddCollateral instruction
    #[derive(Debug, Clone, Default)]
    pub struct AddCollateralInstructionAccountMetas {
        pub pair: AccountMeta,

        pub rate_model: AccountMeta,

        pub futarchy_authority: AccountMeta,

        pub user_position: AccountMeta,

        pub collateral_vault: AccountMeta,

        pub user_collateral_token_account: AccountMeta,

        pub collateral_token_mint: AccountMeta,

        pub user: AccountMeta,

        pub token_program: AccountMeta,

        pub token_2022_program: AccountMeta,

        pub system_program: AccountMeta,

        pub event_authority: AccountMeta,

        pub program: AccountMeta,
    }

    /// Account pubkeys for AddCollateral instruction
    #[derive(Debug, Clone)]
    pub struct AddCollateralInstructionAccounts {
        pub pair: Pubkey,

        pub rate_model: Pubkey,

        pub futarchy_authority: Pubkey,

        pub user_position: Pubkey,

        pub collateral_vault: Pubkey,

        pub user_collateral_token_account: Pubkey,

        pub collateral_token_mint: Pubkey,

        pub user: Pubkey,

        pub event_authority: Pubkey,

        pub program: Pubkey,
    }

    impl AddCollateralInstructionAccounts {
        pub fn new(
            pair: Pubkey,

            rate_model: Pubkey,

            futarchy_authority: Pubkey,

            user_position: Pubkey,

            collateral_vault: Pubkey,

            user_collateral_token_account: Pubkey,

            collateral_token_mint: Pubkey,

            user: Pubkey,

            event_authority: Pubkey,

            program: Pubkey,
        ) -> Self {
            Self {
                pair,

                rate_model,

                futarchy_authority,

                user_position,

                collateral_vault,

                user_collateral_token_account,

                collateral_token_mint,

                user,

                event_authority,

                program,
            }
        }
    }

    /// Instruction data for AddCollateral
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct AddCollateralInstructionData {
        pub args: AdjustPositionArgs,
    }

    impl AddCollateralInstructionData {
        pub fn new(args: AdjustPositionArgs) -> Self {
            Self { args }
        }
    }

    /// Implementation for AddCollateralInstruction
    impl AddCollateralInstruction {
        fn discriminator() -> [u8; 8] {
            [127u8, 82u8, 121u8, 42u8, 161u8, 176u8, 249u8, 206u8]
        }

        pub fn data(data: AddCollateralInstructionData) -> Self {
            Self {
                accounts: AddCollateralInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: AddCollateralInstructionAccounts) -> Self {
            self.accounts.pair = AccountMeta::new(accounts.pair, false);

            self.accounts.rate_model = AccountMeta::new(accounts.rate_model, false);

            self.accounts.futarchy_authority =
                AccountMeta::new_readonly(accounts.futarchy_authority, false);

            self.accounts.user_position = AccountMeta::new(accounts.user_position, false);

            self.accounts.collateral_vault = AccountMeta::new(accounts.collateral_vault, false);

            self.accounts.user_collateral_token_account =
                AccountMeta::new(accounts.user_collateral_token_account, false);

            self.accounts.collateral_token_mint =
                AccountMeta::new_readonly(accounts.collateral_token_mint, false);

            self.accounts.user = AccountMeta::new(accounts.user, true);

            self.accounts.token_program = AccountMeta::new_readonly(
                pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
                false,
            );

            self.accounts.token_2022_program = AccountMeta::new_readonly(
                pubkey!("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),
                false,
            );

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self.accounts.event_authority =
                AccountMeta::new_readonly(accounts.event_authority, false);

            self.accounts.program = AccountMeta::new_readonly(accounts.program, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.pair.clone());

            metas.push(self.accounts.rate_model.clone());

            metas.push(self.accounts.futarchy_authority.clone());

            metas.push(self.accounts.user_position.clone());

            metas.push(self.accounts.collateral_vault.clone());

            metas.push(self.accounts.user_collateral_token_account.clone());

            metas.push(self.accounts.collateral_token_mint.clone());

            metas.push(self.accounts.user.clone());

            metas.push(self.accounts.token_program.clone());

            metas.push(self.accounts.token_2022_program.clone());

            metas.push(self.accounts.system_program.clone());

            metas.push(self.accounts.event_authority.clone());

            metas.push(self.accounts.program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: AddLiquidity
    // ....................................................................

    /// Main instruction struct for AddLiquidity
    pub struct AddLiquidityInstruction {
        pub accounts: AddLiquidityInstructionAccountMetas,
        pub data: AddLiquidityInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for AddLiquidity instruction
    #[derive(Debug, Clone, Default)]
    pub struct AddLiquidityInstructionAccountMetas {
        pub pair: AccountMeta,

        pub rate_model: AccountMeta,

        pub futarchy_authority: AccountMeta,

        pub token0_vault: AccountMeta,

        pub token1_vault: AccountMeta,

        pub user_token0_account: AccountMeta,

        pub user_token1_account: AccountMeta,

        pub token0_vault_mint: AccountMeta,

        pub token1_vault_mint: AccountMeta,

        pub lp_mint: AccountMeta,

        pub user_lp_token_account: AccountMeta,

        pub user: AccountMeta,

        pub token_program: AccountMeta,

        pub token_2022_program: AccountMeta,

        pub associated_token_program: AccountMeta,

        pub system_program: AccountMeta,

        pub event_authority: AccountMeta,

        pub program: AccountMeta,
    }

    /// Account pubkeys for AddLiquidity instruction
    #[derive(Debug, Clone)]
    pub struct AddLiquidityInstructionAccounts {
        pub pair: Pubkey,

        pub rate_model: Pubkey,

        pub futarchy_authority: Pubkey,

        pub token0_vault: Pubkey,

        pub token1_vault: Pubkey,

        pub user_token0_account: Pubkey,

        pub user_token1_account: Pubkey,

        pub token0_vault_mint: Pubkey,

        pub token1_vault_mint: Pubkey,

        pub lp_mint: Pubkey,

        pub user_lp_token_account: Pubkey,

        pub user: Pubkey,

        pub event_authority: Pubkey,

        pub program: Pubkey,
    }

    impl AddLiquidityInstructionAccounts {
        pub fn new(
            pair: Pubkey,

            rate_model: Pubkey,

            futarchy_authority: Pubkey,

            token0_vault: Pubkey,

            token1_vault: Pubkey,

            user_token0_account: Pubkey,

            user_token1_account: Pubkey,

            token0_vault_mint: Pubkey,

            token1_vault_mint: Pubkey,

            lp_mint: Pubkey,

            user_lp_token_account: Pubkey,

            user: Pubkey,

            event_authority: Pubkey,

            program: Pubkey,
        ) -> Self {
            Self {
                pair,

                rate_model,

                futarchy_authority,

                token0_vault,

                token1_vault,

                user_token0_account,

                user_token1_account,

                token0_vault_mint,

                token1_vault_mint,

                lp_mint,

                user_lp_token_account,

                user,

                event_authority,

                program,
            }
        }
    }

    /// Instruction data for AddLiquidity
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct AddLiquidityInstructionData {
        pub args: AddLiquidityArgs,
    }

    impl AddLiquidityInstructionData {
        pub fn new(args: AddLiquidityArgs) -> Self {
            Self { args }
        }
    }

    /// Implementation for AddLiquidityInstruction
    impl AddLiquidityInstruction {
        fn discriminator() -> [u8; 8] {
            [181u8, 157u8, 89u8, 67u8, 143u8, 182u8, 52u8, 72u8]
        }

        pub fn data(data: AddLiquidityInstructionData) -> Self {
            Self {
                accounts: AddLiquidityInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: AddLiquidityInstructionAccounts) -> Self {
            self.accounts.pair = AccountMeta::new(accounts.pair, false);

            self.accounts.rate_model = AccountMeta::new(accounts.rate_model, false);

            self.accounts.futarchy_authority =
                AccountMeta::new_readonly(accounts.futarchy_authority, false);

            self.accounts.token0_vault = AccountMeta::new(accounts.token0_vault, false);

            self.accounts.token1_vault = AccountMeta::new(accounts.token1_vault, false);

            self.accounts.user_token0_account =
                AccountMeta::new(accounts.user_token0_account, false);

            self.accounts.user_token1_account =
                AccountMeta::new(accounts.user_token1_account, false);

            self.accounts.token0_vault_mint =
                AccountMeta::new_readonly(accounts.token0_vault_mint, false);

            self.accounts.token1_vault_mint =
                AccountMeta::new_readonly(accounts.token1_vault_mint, false);

            self.accounts.lp_mint = AccountMeta::new(accounts.lp_mint, false);

            self.accounts.user_lp_token_account =
                AccountMeta::new(accounts.user_lp_token_account, false);

            self.accounts.user = AccountMeta::new(accounts.user, true);

            self.accounts.token_program = AccountMeta::new_readonly(
                pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
                false,
            );

            self.accounts.token_2022_program = AccountMeta::new_readonly(
                pubkey!("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),
                false,
            );

            self.accounts.associated_token_program = AccountMeta::new_readonly(
                pubkey!("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"),
                false,
            );

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self.accounts.event_authority =
                AccountMeta::new_readonly(accounts.event_authority, false);

            self.accounts.program = AccountMeta::new_readonly(accounts.program, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.pair.clone());

            metas.push(self.accounts.rate_model.clone());

            metas.push(self.accounts.futarchy_authority.clone());

            metas.push(self.accounts.token0_vault.clone());

            metas.push(self.accounts.token1_vault.clone());

            metas.push(self.accounts.user_token0_account.clone());

            metas.push(self.accounts.user_token1_account.clone());

            metas.push(self.accounts.token0_vault_mint.clone());

            metas.push(self.accounts.token1_vault_mint.clone());

            metas.push(self.accounts.lp_mint.clone());

            metas.push(self.accounts.user_lp_token_account.clone());

            metas.push(self.accounts.user.clone());

            metas.push(self.accounts.token_program.clone());

            metas.push(self.accounts.token_2022_program.clone());

            metas.push(self.accounts.associated_token_program.clone());

            metas.push(self.accounts.system_program.clone());

            metas.push(self.accounts.event_authority.clone());

            metas.push(self.accounts.program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: Borrow
    // ....................................................................

    /// Main instruction struct for Borrow
    pub struct BorrowInstruction {
        pub accounts: BorrowInstructionAccountMetas,
        pub data: BorrowInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for Borrow instruction
    #[derive(Debug, Clone, Default)]
    pub struct BorrowInstructionAccountMetas {
        pub pair: AccountMeta,

        pub user_position: AccountMeta,

        pub rate_model: AccountMeta,

        pub futarchy_authority: AccountMeta,

        pub token_vault: AccountMeta,

        pub user_token_account: AccountMeta,

        pub vault_token_mint: AccountMeta,

        pub user: AccountMeta,

        pub token_program: AccountMeta,

        pub token_2022_program: AccountMeta,

        pub system_program: AccountMeta,

        pub event_authority: AccountMeta,

        pub program: AccountMeta,
    }

    /// Account pubkeys for Borrow instruction
    #[derive(Debug, Clone)]
    pub struct BorrowInstructionAccounts {
        pub pair: Pubkey,

        pub user_position: Pubkey,

        pub rate_model: Pubkey,

        pub futarchy_authority: Pubkey,

        pub token_vault: Pubkey,

        pub user_token_account: Pubkey,

        pub vault_token_mint: Pubkey,

        pub user: Pubkey,

        pub event_authority: Pubkey,

        pub program: Pubkey,
    }

    impl BorrowInstructionAccounts {
        pub fn new(
            pair: Pubkey,

            user_position: Pubkey,

            rate_model: Pubkey,

            futarchy_authority: Pubkey,

            token_vault: Pubkey,

            user_token_account: Pubkey,

            vault_token_mint: Pubkey,

            user: Pubkey,

            event_authority: Pubkey,

            program: Pubkey,
        ) -> Self {
            Self {
                pair,

                user_position,

                rate_model,

                futarchy_authority,

                token_vault,

                user_token_account,

                vault_token_mint,

                user,

                event_authority,

                program,
            }
        }
    }

    /// Instruction data for Borrow
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct BorrowInstructionData {
        pub args: AdjustPositionArgs,
    }

    impl BorrowInstructionData {
        pub fn new(args: AdjustPositionArgs) -> Self {
            Self { args }
        }
    }

    /// Implementation for BorrowInstruction
    impl BorrowInstruction {
        fn discriminator() -> [u8; 8] {
            [228u8, 253u8, 131u8, 202u8, 207u8, 116u8, 89u8, 18u8]
        }

        pub fn data(data: BorrowInstructionData) -> Self {
            Self {
                accounts: BorrowInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: BorrowInstructionAccounts) -> Self {
            self.accounts.pair = AccountMeta::new(accounts.pair, false);

            self.accounts.user_position = AccountMeta::new(accounts.user_position, false);

            self.accounts.rate_model = AccountMeta::new(accounts.rate_model, false);

            self.accounts.futarchy_authority =
                AccountMeta::new_readonly(accounts.futarchy_authority, false);

            self.accounts.token_vault = AccountMeta::new(accounts.token_vault, false);

            self.accounts.user_token_account = AccountMeta::new(accounts.user_token_account, false);

            self.accounts.vault_token_mint =
                AccountMeta::new_readonly(accounts.vault_token_mint, false);

            self.accounts.user = AccountMeta::new(accounts.user, true);

            self.accounts.token_program = AccountMeta::new_readonly(
                pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
                false,
            );

            self.accounts.token_2022_program = AccountMeta::new_readonly(
                pubkey!("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),
                false,
            );

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self.accounts.event_authority =
                AccountMeta::new_readonly(accounts.event_authority, false);

            self.accounts.program = AccountMeta::new_readonly(accounts.program, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.pair.clone());

            metas.push(self.accounts.user_position.clone());

            metas.push(self.accounts.rate_model.clone());

            metas.push(self.accounts.futarchy_authority.clone());

            metas.push(self.accounts.token_vault.clone());

            metas.push(self.accounts.user_token_account.clone());

            metas.push(self.accounts.vault_token_mint.clone());

            metas.push(self.accounts.user.clone());

            metas.push(self.accounts.token_program.clone());

            metas.push(self.accounts.token_2022_program.clone());

            metas.push(self.accounts.system_program.clone());

            metas.push(self.accounts.event_authority.clone());

            metas.push(self.accounts.program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: ClaimProtocolFees
    // ....................................................................

    /// Main instruction struct for ClaimProtocolFees
    pub struct ClaimProtocolFeesInstruction {
        pub accounts: ClaimProtocolFeesInstructionAccountMetas,
        pub data: ClaimProtocolFeesInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for ClaimProtocolFees instruction
    #[derive(Debug, Clone, Default)]
    pub struct ClaimProtocolFeesInstructionAccountMetas {
        pub caller: AccountMeta,

        pub pair: AccountMeta,

        pub futarchy_authority: AccountMeta,

        pub token0_vault: AccountMeta,

        pub token1_vault: AccountMeta,

        pub authority_token0_account: AccountMeta,

        pub authority_token1_account: AccountMeta,

        pub token0_mint: AccountMeta,

        pub token1_mint: AccountMeta,

        pub token_program: AccountMeta,

        pub token_2022_program: AccountMeta,

        pub associated_token_program: AccountMeta,

        pub system_program: AccountMeta,
    }

    /// Account pubkeys for ClaimProtocolFees instruction
    #[derive(Debug, Clone)]
    pub struct ClaimProtocolFeesInstructionAccounts {
        pub caller: Pubkey,

        pub pair: Pubkey,

        pub futarchy_authority: Pubkey,

        pub token0_vault: Pubkey,

        pub token1_vault: Pubkey,

        pub authority_token0_account: Pubkey,

        pub authority_token1_account: Pubkey,

        pub token0_mint: Pubkey,

        pub token1_mint: Pubkey,
    }

    impl ClaimProtocolFeesInstructionAccounts {
        pub fn new(
            caller: Pubkey,

            pair: Pubkey,

            futarchy_authority: Pubkey,

            token0_vault: Pubkey,

            token1_vault: Pubkey,

            authority_token0_account: Pubkey,

            authority_token1_account: Pubkey,

            token0_mint: Pubkey,

            token1_mint: Pubkey,
        ) -> Self {
            Self {
                caller,

                pair,

                futarchy_authority,

                token0_vault,

                token1_vault,

                authority_token0_account,

                authority_token1_account,

                token0_mint,

                token1_mint,
            }
        }
    }

    /// Instruction data for ClaimProtocolFees
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct ClaimProtocolFeesInstructionData {
        pub args: ClaimProtocolFeesArgs,
    }

    impl ClaimProtocolFeesInstructionData {
        pub fn new(args: ClaimProtocolFeesArgs) -> Self {
            Self { args }
        }
    }

    /// Implementation for ClaimProtocolFeesInstruction
    impl ClaimProtocolFeesInstruction {
        fn discriminator() -> [u8; 8] {
            [34u8, 142u8, 219u8, 112u8, 109u8, 54u8, 133u8, 23u8]
        }

        pub fn data(data: ClaimProtocolFeesInstructionData) -> Self {
            Self {
                accounts: ClaimProtocolFeesInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: ClaimProtocolFeesInstructionAccounts) -> Self {
            self.accounts.caller = AccountMeta::new(accounts.caller, true);

            self.accounts.pair = AccountMeta::new(accounts.pair, false);

            self.accounts.futarchy_authority =
                AccountMeta::new_readonly(accounts.futarchy_authority, false);

            self.accounts.token0_vault = AccountMeta::new(accounts.token0_vault, false);

            self.accounts.token1_vault = AccountMeta::new(accounts.token1_vault, false);

            self.accounts.authority_token0_account =
                AccountMeta::new(accounts.authority_token0_account, false);

            self.accounts.authority_token1_account =
                AccountMeta::new(accounts.authority_token1_account, false);

            self.accounts.token0_mint = AccountMeta::new_readonly(accounts.token0_mint, false);

            self.accounts.token1_mint = AccountMeta::new_readonly(accounts.token1_mint, false);

            self.accounts.token_program = AccountMeta::new_readonly(
                pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
                false,
            );

            self.accounts.token_2022_program = AccountMeta::new_readonly(
                pubkey!("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),
                false,
            );

            self.accounts.associated_token_program = AccountMeta::new_readonly(
                pubkey!("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"),
                false,
            );

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.caller.clone());

            metas.push(self.accounts.pair.clone());

            metas.push(self.accounts.futarchy_authority.clone());

            metas.push(self.accounts.token0_vault.clone());

            metas.push(self.accounts.token1_vault.clone());

            metas.push(self.accounts.authority_token0_account.clone());

            metas.push(self.accounts.authority_token1_account.clone());

            metas.push(self.accounts.token0_mint.clone());

            metas.push(self.accounts.token1_mint.clone());

            metas.push(self.accounts.token_program.clone());

            metas.push(self.accounts.token_2022_program.clone());

            metas.push(self.accounts.associated_token_program.clone());

            metas.push(self.accounts.system_program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: DistributeTokens
    // ....................................................................

    /// Main instruction struct for DistributeTokens
    pub struct DistributeTokensInstruction {
        pub accounts: DistributeTokensInstructionAccountMetas,
        pub data: DistributeTokensInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for DistributeTokens instruction
    #[derive(Debug, Clone, Default)]
    pub struct DistributeTokensInstructionAccountMetas {
        pub futarchy_authority: AccountMeta,

        pub source_mint: AccountMeta,

        pub source_token_account: AccountMeta,

        pub futarchy_treasury_token_account: AccountMeta,

        pub buybacks_vault_token_account: AccountMeta,

        pub team_treasury_token_account: AccountMeta,

        pub token_program: AccountMeta,
    }

    /// Account pubkeys for DistributeTokens instruction
    #[derive(Debug, Clone)]
    pub struct DistributeTokensInstructionAccounts {
        pub futarchy_authority: Pubkey,

        pub source_mint: Pubkey,

        pub source_token_account: Pubkey,

        pub futarchy_treasury_token_account: Pubkey,

        pub buybacks_vault_token_account: Pubkey,

        pub team_treasury_token_account: Pubkey,
    }

    impl DistributeTokensInstructionAccounts {
        pub fn new(
            futarchy_authority: Pubkey,

            source_mint: Pubkey,

            source_token_account: Pubkey,

            futarchy_treasury_token_account: Pubkey,

            buybacks_vault_token_account: Pubkey,

            team_treasury_token_account: Pubkey,
        ) -> Self {
            Self {
                futarchy_authority,

                source_mint,

                source_token_account,

                futarchy_treasury_token_account,

                buybacks_vault_token_account,

                team_treasury_token_account,
            }
        }
    }

    /// Instruction data for DistributeTokens
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct DistributeTokensInstructionData {
        pub args: DistributeTokensArgs,
    }

    impl DistributeTokensInstructionData {
        pub fn new(args: DistributeTokensArgs) -> Self {
            Self { args }
        }
    }

    /// Implementation for DistributeTokensInstruction
    impl DistributeTokensInstruction {
        fn discriminator() -> [u8; 8] {
            [105u8, 69u8, 130u8, 52u8, 196u8, 28u8, 176u8, 120u8]
        }

        pub fn data(data: DistributeTokensInstructionData) -> Self {
            Self {
                accounts: DistributeTokensInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: DistributeTokensInstructionAccounts) -> Self {
            self.accounts.futarchy_authority =
                AccountMeta::new_readonly(accounts.futarchy_authority, false);

            self.accounts.source_mint = AccountMeta::new_readonly(accounts.source_mint, false);

            self.accounts.source_token_account =
                AccountMeta::new(accounts.source_token_account, false);

            self.accounts.futarchy_treasury_token_account =
                AccountMeta::new(accounts.futarchy_treasury_token_account, false);

            self.accounts.buybacks_vault_token_account =
                AccountMeta::new(accounts.buybacks_vault_token_account, false);

            self.accounts.team_treasury_token_account =
                AccountMeta::new(accounts.team_treasury_token_account, false);

            self.accounts.token_program = AccountMeta::new_readonly(
                pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
                false,
            );

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.futarchy_authority.clone());

            metas.push(self.accounts.source_mint.clone());

            metas.push(self.accounts.source_token_account.clone());

            metas.push(self.accounts.futarchy_treasury_token_account.clone());

            metas.push(self.accounts.buybacks_vault_token_account.clone());

            metas.push(self.accounts.team_treasury_token_account.clone());

            metas.push(self.accounts.token_program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: Flashloan
    // ....................................................................

    /// Main instruction struct for Flashloan
    pub struct FlashloanInstruction {
        pub accounts: FlashloanInstructionAccountMetas,
        pub data: FlashloanInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for Flashloan instruction
    #[derive(Debug, Clone, Default)]
    pub struct FlashloanInstructionAccountMetas {
        pub pair: AccountMeta,

        pub rate_model: AccountMeta,

        pub futarchy_authority: AccountMeta,

        pub token0_vault: AccountMeta,

        pub token1_vault: AccountMeta,

        pub token0_mint: AccountMeta,

        pub token1_mint: AccountMeta,

        pub receiver_token0_account: AccountMeta,

        pub receiver_token1_account: AccountMeta,

        pub receiver_program: AccountMeta,

        pub user: AccountMeta,

        pub token_program: AccountMeta,

        pub token_2022_program: AccountMeta,

        pub system_program: AccountMeta,

        pub event_authority: AccountMeta,

        pub program: AccountMeta,
    }

    /// Account pubkeys for Flashloan instruction
    #[derive(Debug, Clone)]
    pub struct FlashloanInstructionAccounts {
        pub pair: Pubkey,

        pub rate_model: Pubkey,

        pub futarchy_authority: Pubkey,

        pub token0_vault: Pubkey,

        pub token1_vault: Pubkey,

        pub token0_mint: Pubkey,

        pub token1_mint: Pubkey,

        pub receiver_token0_account: Pubkey,

        pub receiver_token1_account: Pubkey,

        pub receiver_program: Pubkey,

        pub user: Pubkey,

        pub event_authority: Pubkey,

        pub program: Pubkey,
    }

    impl FlashloanInstructionAccounts {
        pub fn new(
            pair: Pubkey,

            rate_model: Pubkey,

            futarchy_authority: Pubkey,

            token0_vault: Pubkey,

            token1_vault: Pubkey,

            token0_mint: Pubkey,

            token1_mint: Pubkey,

            receiver_token0_account: Pubkey,

            receiver_token1_account: Pubkey,

            receiver_program: Pubkey,

            user: Pubkey,

            event_authority: Pubkey,

            program: Pubkey,
        ) -> Self {
            Self {
                pair,

                rate_model,

                futarchy_authority,

                token0_vault,

                token1_vault,

                token0_mint,

                token1_mint,

                receiver_token0_account,

                receiver_token1_account,

                receiver_program,

                user,

                event_authority,

                program,
            }
        }
    }

    /// Instruction data for Flashloan
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct FlashloanInstructionData {
        pub args: FlashloanArgs,
    }

    impl FlashloanInstructionData {
        pub fn new(args: FlashloanArgs) -> Self {
            Self { args }
        }
    }

    /// Implementation for FlashloanInstruction
    impl FlashloanInstruction {
        fn discriminator() -> [u8; 8] {
            [105u8, 33u8, 1u8, 3u8, 42u8, 158u8, 246u8, 67u8]
        }

        pub fn data(data: FlashloanInstructionData) -> Self {
            Self {
                accounts: FlashloanInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: FlashloanInstructionAccounts) -> Self {
            self.accounts.pair = AccountMeta::new(accounts.pair, false);

            self.accounts.rate_model = AccountMeta::new(accounts.rate_model, false);

            self.accounts.futarchy_authority =
                AccountMeta::new_readonly(accounts.futarchy_authority, false);

            self.accounts.token0_vault = AccountMeta::new(accounts.token0_vault, false);

            self.accounts.token1_vault = AccountMeta::new(accounts.token1_vault, false);

            self.accounts.token0_mint = AccountMeta::new_readonly(accounts.token0_mint, false);

            self.accounts.token1_mint = AccountMeta::new_readonly(accounts.token1_mint, false);

            self.accounts.receiver_token0_account =
                AccountMeta::new(accounts.receiver_token0_account, false);

            self.accounts.receiver_token1_account =
                AccountMeta::new(accounts.receiver_token1_account, false);

            self.accounts.receiver_program =
                AccountMeta::new_readonly(accounts.receiver_program, false);

            self.accounts.user = AccountMeta::new_readonly(accounts.user, true);

            self.accounts.token_program = AccountMeta::new_readonly(
                pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
                false,
            );

            self.accounts.token_2022_program = AccountMeta::new_readonly(
                pubkey!("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),
                false,
            );

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self.accounts.event_authority =
                AccountMeta::new_readonly(accounts.event_authority, false);

            self.accounts.program = AccountMeta::new_readonly(accounts.program, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.pair.clone());

            metas.push(self.accounts.rate_model.clone());

            metas.push(self.accounts.futarchy_authority.clone());

            metas.push(self.accounts.token0_vault.clone());

            metas.push(self.accounts.token1_vault.clone());

            metas.push(self.accounts.token0_mint.clone());

            metas.push(self.accounts.token1_mint.clone());

            metas.push(self.accounts.receiver_token0_account.clone());

            metas.push(self.accounts.receiver_token1_account.clone());

            metas.push(self.accounts.receiver_program.clone());

            metas.push(self.accounts.user.clone());

            metas.push(self.accounts.token_program.clone());

            metas.push(self.accounts.token_2022_program.clone());

            metas.push(self.accounts.system_program.clone());

            metas.push(self.accounts.event_authority.clone());

            metas.push(self.accounts.program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: InitFutarchyAuthority
    // ....................................................................

    /// Main instruction struct for InitFutarchyAuthority
    pub struct InitFutarchyAuthorityInstruction {
        pub accounts: InitFutarchyAuthorityInstructionAccountMetas,
        pub data: InitFutarchyAuthorityInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for InitFutarchyAuthority instruction
    #[derive(Debug, Clone, Default)]
    pub struct InitFutarchyAuthorityInstructionAccountMetas {
        pub deployer: AccountMeta,

        pub futarchy_authority: AccountMeta,

        pub system_program: AccountMeta,
    }

    /// Account pubkeys for InitFutarchyAuthority instruction
    #[derive(Debug, Clone)]
    pub struct InitFutarchyAuthorityInstructionAccounts {
        pub futarchy_authority: Pubkey,
    }

    impl InitFutarchyAuthorityInstructionAccounts {
        pub fn new(futarchy_authority: Pubkey) -> Self {
            Self { futarchy_authority }
        }
    }

    /// Instruction data for InitFutarchyAuthority
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct InitFutarchyAuthorityInstructionData {
        pub args: InitFutarchyAuthorityArgs,
    }

    impl InitFutarchyAuthorityInstructionData {
        pub fn new(args: InitFutarchyAuthorityArgs) -> Self {
            Self { args }
        }
    }

    /// Implementation for InitFutarchyAuthorityInstruction
    impl InitFutarchyAuthorityInstruction {
        fn discriminator() -> [u8; 8] {
            [133u8, 110u8, 154u8, 29u8, 240u8, 206u8, 71u8, 100u8]
        }

        pub fn data(data: InitFutarchyAuthorityInstructionData) -> Self {
            Self {
                accounts: InitFutarchyAuthorityInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: InitFutarchyAuthorityInstructionAccounts) -> Self {
            self.accounts.deployer = AccountMeta::new(
                pubkey!("C7GKpfqQyBoFR6S13DECwBjdi7aCQKbbeKjXm4Jt5Hds"),
                true,
            );

            self.accounts.futarchy_authority = AccountMeta::new(accounts.futarchy_authority, false);

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.deployer.clone());

            metas.push(self.accounts.futarchy_authority.clone());

            metas.push(self.accounts.system_program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: Initialize
    // ....................................................................

    /// Main instruction struct for Initialize
    pub struct InitializeInstruction {
        pub accounts: InitializeInstructionAccountMetas,
        pub data: InitializeInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for Initialize instruction
    #[derive(Debug, Clone, Default)]
    pub struct InitializeInstructionAccountMetas {
        pub deployer: AccountMeta,

        pub token0_mint: AccountMeta,

        pub token1_mint: AccountMeta,

        pub pair: AccountMeta,

        pub futarchy_authority: AccountMeta,

        pub rate_model: AccountMeta,

        pub lp_mint: AccountMeta,

        pub lp_token_metadata: AccountMeta,

        pub deployer_lp_token_account: AccountMeta,

        pub token0_vault: AccountMeta,

        pub token1_vault: AccountMeta,

        pub deployer_token0_account: AccountMeta,

        pub deployer_token1_account: AccountMeta,

        pub authority_wsol_account: AccountMeta,

        pub system_program: AccountMeta,

        pub token_program: AccountMeta,

        pub token_2022_program: AccountMeta,

        pub token_metadata_program: AccountMeta,

        pub associated_token_program: AccountMeta,

        pub rent: AccountMeta,

        pub event_authority: AccountMeta,

        pub program: AccountMeta,
    }

    /// Account pubkeys for Initialize instruction
    #[derive(Debug, Clone)]
    pub struct InitializeInstructionAccounts {
        pub deployer: Pubkey,

        pub token0_mint: Pubkey,

        pub token1_mint: Pubkey,

        pub pair: Pubkey,

        pub futarchy_authority: Pubkey,

        pub rate_model: Pubkey,

        pub lp_mint: Pubkey,

        pub lp_token_metadata: Pubkey,

        pub deployer_lp_token_account: Pubkey,

        pub token0_vault: Pubkey,

        pub token1_vault: Pubkey,

        pub deployer_token0_account: Pubkey,

        pub deployer_token1_account: Pubkey,

        pub authority_wsol_account: Pubkey,

        pub event_authority: Pubkey,

        pub program: Pubkey,
    }

    impl InitializeInstructionAccounts {
        pub fn new(
            deployer: Pubkey,

            token0_mint: Pubkey,

            token1_mint: Pubkey,

            pair: Pubkey,

            futarchy_authority: Pubkey,

            rate_model: Pubkey,

            lp_mint: Pubkey,

            lp_token_metadata: Pubkey,

            deployer_lp_token_account: Pubkey,

            token0_vault: Pubkey,

            token1_vault: Pubkey,

            deployer_token0_account: Pubkey,

            deployer_token1_account: Pubkey,

            authority_wsol_account: Pubkey,

            event_authority: Pubkey,

            program: Pubkey,
        ) -> Self {
            Self {
                deployer,

                token0_mint,

                token1_mint,

                pair,

                futarchy_authority,

                rate_model,

                lp_mint,

                lp_token_metadata,

                deployer_lp_token_account,

                token0_vault,

                token1_vault,

                deployer_token0_account,

                deployer_token1_account,

                authority_wsol_account,

                event_authority,

                program,
            }
        }
    }

    /// Instruction data for Initialize
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct InitializeInstructionData {
        pub args: InitializeAndBootstrapArgs,
    }

    impl InitializeInstructionData {
        pub fn new(args: InitializeAndBootstrapArgs) -> Self {
            Self { args }
        }
    }

    /// Implementation for InitializeInstruction
    impl InitializeInstruction {
        fn discriminator() -> [u8; 8] {
            [175u8, 175u8, 109u8, 31u8, 13u8, 152u8, 155u8, 237u8]
        }

        pub fn data(data: InitializeInstructionData) -> Self {
            Self {
                accounts: InitializeInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: InitializeInstructionAccounts) -> Self {
            self.accounts.deployer = AccountMeta::new(accounts.deployer, true);

            self.accounts.token0_mint = AccountMeta::new_readonly(accounts.token0_mint, false);

            self.accounts.token1_mint = AccountMeta::new_readonly(accounts.token1_mint, false);

            self.accounts.pair = AccountMeta::new(accounts.pair, false);

            self.accounts.futarchy_authority =
                AccountMeta::new_readonly(accounts.futarchy_authority, false);

            self.accounts.rate_model = AccountMeta::new(accounts.rate_model, true);

            self.accounts.lp_mint = AccountMeta::new(accounts.lp_mint, false);

            self.accounts.lp_token_metadata = AccountMeta::new(accounts.lp_token_metadata, false);

            self.accounts.deployer_lp_token_account =
                AccountMeta::new(accounts.deployer_lp_token_account, false);

            self.accounts.token0_vault = AccountMeta::new(accounts.token0_vault, false);

            self.accounts.token1_vault = AccountMeta::new(accounts.token1_vault, false);

            self.accounts.deployer_token0_account =
                AccountMeta::new(accounts.deployer_token0_account, false);

            self.accounts.deployer_token1_account =
                AccountMeta::new(accounts.deployer_token1_account, false);

            self.accounts.authority_wsol_account =
                AccountMeta::new(accounts.authority_wsol_account, false);

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self.accounts.token_program = AccountMeta::new_readonly(
                pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
                false,
            );

            self.accounts.token_2022_program = AccountMeta::new_readonly(
                pubkey!("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),
                false,
            );

            self.accounts.token_metadata_program = AccountMeta::new_readonly(
                pubkey!("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"),
                false,
            );

            self.accounts.associated_token_program = AccountMeta::new_readonly(
                pubkey!("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"),
                false,
            );

            self.accounts.rent = AccountMeta::new_readonly(
                pubkey!("SysvarRent111111111111111111111111111111111"),
                false,
            );

            self.accounts.event_authority =
                AccountMeta::new_readonly(accounts.event_authority, false);

            self.accounts.program = AccountMeta::new_readonly(accounts.program, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.deployer.clone());

            metas.push(self.accounts.token0_mint.clone());

            metas.push(self.accounts.token1_mint.clone());

            metas.push(self.accounts.pair.clone());

            metas.push(self.accounts.futarchy_authority.clone());

            metas.push(self.accounts.rate_model.clone());

            metas.push(self.accounts.lp_mint.clone());

            metas.push(self.accounts.lp_token_metadata.clone());

            metas.push(self.accounts.deployer_lp_token_account.clone());

            metas.push(self.accounts.token0_vault.clone());

            metas.push(self.accounts.token1_vault.clone());

            metas.push(self.accounts.deployer_token0_account.clone());

            metas.push(self.accounts.deployer_token1_account.clone());

            metas.push(self.accounts.authority_wsol_account.clone());

            metas.push(self.accounts.system_program.clone());

            metas.push(self.accounts.token_program.clone());

            metas.push(self.accounts.token_2022_program.clone());

            metas.push(self.accounts.token_metadata_program.clone());

            metas.push(self.accounts.associated_token_program.clone());

            metas.push(self.accounts.rent.clone());

            metas.push(self.accounts.event_authority.clone());

            metas.push(self.accounts.program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: Liquidate
    // ....................................................................

    /// Main instruction struct for Liquidate
    pub struct LiquidateInstruction {
        pub accounts: LiquidateInstructionAccountMetas,
        pub data: LiquidateInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for Liquidate instruction
    #[derive(Debug, Clone, Default)]
    pub struct LiquidateInstructionAccountMetas {
        pub pair: AccountMeta,

        pub user_position: AccountMeta,

        pub rate_model: AccountMeta,

        pub futarchy_authority: AccountMeta,

        pub collateral_vault: AccountMeta,

        pub caller_token_account: AccountMeta,

        pub collateral_token_mint: AccountMeta,

        pub position_owner: AccountMeta,

        pub payer: AccountMeta,

        pub token_program: AccountMeta,

        pub token_2022_program: AccountMeta,

        pub system_program: AccountMeta,

        pub event_authority: AccountMeta,

        pub program: AccountMeta,
    }

    /// Account pubkeys for Liquidate instruction
    #[derive(Debug, Clone)]
    pub struct LiquidateInstructionAccounts {
        pub pair: Pubkey,

        pub user_position: Pubkey,

        pub rate_model: Pubkey,

        pub futarchy_authority: Pubkey,

        pub collateral_vault: Pubkey,

        pub caller_token_account: Pubkey,

        pub collateral_token_mint: Pubkey,

        pub position_owner: Pubkey,

        pub payer: Pubkey,

        pub event_authority: Pubkey,

        pub program: Pubkey,
    }

    impl LiquidateInstructionAccounts {
        pub fn new(
            pair: Pubkey,

            user_position: Pubkey,

            rate_model: Pubkey,

            futarchy_authority: Pubkey,

            collateral_vault: Pubkey,

            caller_token_account: Pubkey,

            collateral_token_mint: Pubkey,

            position_owner: Pubkey,

            payer: Pubkey,

            event_authority: Pubkey,

            program: Pubkey,
        ) -> Self {
            Self {
                pair,

                user_position,

                rate_model,

                futarchy_authority,

                collateral_vault,

                caller_token_account,

                collateral_token_mint,

                position_owner,

                payer,

                event_authority,

                program,
            }
        }
    }

    /// Instruction data for Liquidate
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct LiquidateInstructionData {}

    impl LiquidateInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for LiquidateInstruction
    impl LiquidateInstruction {
        fn discriminator() -> [u8; 8] {
            [223u8, 179u8, 226u8, 125u8, 48u8, 46u8, 39u8, 74u8]
        }

        pub fn data(data: LiquidateInstructionData) -> Self {
            Self {
                accounts: LiquidateInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: LiquidateInstructionAccounts) -> Self {
            self.accounts.pair = AccountMeta::new(accounts.pair, false);

            self.accounts.user_position = AccountMeta::new(accounts.user_position, false);

            self.accounts.rate_model = AccountMeta::new(accounts.rate_model, false);

            self.accounts.futarchy_authority =
                AccountMeta::new_readonly(accounts.futarchy_authority, false);

            self.accounts.collateral_vault = AccountMeta::new(accounts.collateral_vault, false);

            self.accounts.caller_token_account =
                AccountMeta::new(accounts.caller_token_account, false);

            self.accounts.collateral_token_mint =
                AccountMeta::new_readonly(accounts.collateral_token_mint, false);

            self.accounts.position_owner =
                AccountMeta::new_readonly(accounts.position_owner, false);

            self.accounts.payer = AccountMeta::new(accounts.payer, true);

            self.accounts.token_program = AccountMeta::new_readonly(
                pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
                false,
            );

            self.accounts.token_2022_program = AccountMeta::new_readonly(
                pubkey!("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),
                false,
            );

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self.accounts.event_authority =
                AccountMeta::new_readonly(accounts.event_authority, false);

            self.accounts.program = AccountMeta::new_readonly(accounts.program, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.pair.clone());

            metas.push(self.accounts.user_position.clone());

            metas.push(self.accounts.rate_model.clone());

            metas.push(self.accounts.futarchy_authority.clone());

            metas.push(self.accounts.collateral_vault.clone());

            metas.push(self.accounts.caller_token_account.clone());

            metas.push(self.accounts.collateral_token_mint.clone());

            metas.push(self.accounts.position_owner.clone());

            metas.push(self.accounts.payer.clone());

            metas.push(self.accounts.token_program.clone());

            metas.push(self.accounts.token_2022_program.clone());

            metas.push(self.accounts.system_program.clone());

            metas.push(self.accounts.event_authority.clone());

            metas.push(self.accounts.program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: RemoveCollateral
    // ....................................................................

    /// Main instruction struct for RemoveCollateral
    pub struct RemoveCollateralInstruction {
        pub accounts: RemoveCollateralInstructionAccountMetas,
        pub data: RemoveCollateralInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for RemoveCollateral instruction
    #[derive(Debug, Clone, Default)]
    pub struct RemoveCollateralInstructionAccountMetas {
        pub pair: AccountMeta,

        pub user_position: AccountMeta,

        pub rate_model: AccountMeta,

        pub futarchy_authority: AccountMeta,

        pub token_vault: AccountMeta,

        pub user_token_account: AccountMeta,

        pub vault_token_mint: AccountMeta,

        pub user: AccountMeta,

        pub token_program: AccountMeta,

        pub token_2022_program: AccountMeta,

        pub system_program: AccountMeta,

        pub event_authority: AccountMeta,

        pub program: AccountMeta,
    }

    /// Account pubkeys for RemoveCollateral instruction
    #[derive(Debug, Clone)]
    pub struct RemoveCollateralInstructionAccounts {
        pub pair: Pubkey,

        pub user_position: Pubkey,

        pub rate_model: Pubkey,

        pub futarchy_authority: Pubkey,

        pub token_vault: Pubkey,

        pub user_token_account: Pubkey,

        pub vault_token_mint: Pubkey,

        pub user: Pubkey,

        pub event_authority: Pubkey,

        pub program: Pubkey,
    }

    impl RemoveCollateralInstructionAccounts {
        pub fn new(
            pair: Pubkey,

            user_position: Pubkey,

            rate_model: Pubkey,

            futarchy_authority: Pubkey,

            token_vault: Pubkey,

            user_token_account: Pubkey,

            vault_token_mint: Pubkey,

            user: Pubkey,

            event_authority: Pubkey,

            program: Pubkey,
        ) -> Self {
            Self {
                pair,

                user_position,

                rate_model,

                futarchy_authority,

                token_vault,

                user_token_account,

                vault_token_mint,

                user,

                event_authority,

                program,
            }
        }
    }

    /// Instruction data for RemoveCollateral
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct RemoveCollateralInstructionData {
        pub args: AdjustPositionArgs,
    }

    impl RemoveCollateralInstructionData {
        pub fn new(args: AdjustPositionArgs) -> Self {
            Self { args }
        }
    }

    /// Implementation for RemoveCollateralInstruction
    impl RemoveCollateralInstruction {
        fn discriminator() -> [u8; 8] {
            [86u8, 222u8, 130u8, 86u8, 92u8, 20u8, 72u8, 65u8]
        }

        pub fn data(data: RemoveCollateralInstructionData) -> Self {
            Self {
                accounts: RemoveCollateralInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: RemoveCollateralInstructionAccounts) -> Self {
            self.accounts.pair = AccountMeta::new(accounts.pair, false);

            self.accounts.user_position = AccountMeta::new(accounts.user_position, false);

            self.accounts.rate_model = AccountMeta::new(accounts.rate_model, false);

            self.accounts.futarchy_authority =
                AccountMeta::new_readonly(accounts.futarchy_authority, false);

            self.accounts.token_vault = AccountMeta::new(accounts.token_vault, false);

            self.accounts.user_token_account = AccountMeta::new(accounts.user_token_account, false);

            self.accounts.vault_token_mint =
                AccountMeta::new_readonly(accounts.vault_token_mint, false);

            self.accounts.user = AccountMeta::new(accounts.user, true);

            self.accounts.token_program = AccountMeta::new_readonly(
                pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
                false,
            );

            self.accounts.token_2022_program = AccountMeta::new_readonly(
                pubkey!("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),
                false,
            );

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self.accounts.event_authority =
                AccountMeta::new_readonly(accounts.event_authority, false);

            self.accounts.program = AccountMeta::new_readonly(accounts.program, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.pair.clone());

            metas.push(self.accounts.user_position.clone());

            metas.push(self.accounts.rate_model.clone());

            metas.push(self.accounts.futarchy_authority.clone());

            metas.push(self.accounts.token_vault.clone());

            metas.push(self.accounts.user_token_account.clone());

            metas.push(self.accounts.vault_token_mint.clone());

            metas.push(self.accounts.user.clone());

            metas.push(self.accounts.token_program.clone());

            metas.push(self.accounts.token_2022_program.clone());

            metas.push(self.accounts.system_program.clone());

            metas.push(self.accounts.event_authority.clone());

            metas.push(self.accounts.program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: RemoveLiquidity
    // ....................................................................

    /// Main instruction struct for RemoveLiquidity
    pub struct RemoveLiquidityInstruction {
        pub accounts: RemoveLiquidityInstructionAccountMetas,
        pub data: RemoveLiquidityInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for RemoveLiquidity instruction
    #[derive(Debug, Clone, Default)]
    pub struct RemoveLiquidityInstructionAccountMetas {
        pub pair: AccountMeta,

        pub rate_model: AccountMeta,

        pub futarchy_authority: AccountMeta,

        pub token0_vault: AccountMeta,

        pub token1_vault: AccountMeta,

        pub user_token0_account: AccountMeta,

        pub user_token1_account: AccountMeta,

        pub token0_vault_mint: AccountMeta,

        pub token1_vault_mint: AccountMeta,

        pub lp_mint: AccountMeta,

        pub user_lp_token_account: AccountMeta,

        pub user: AccountMeta,

        pub token_program: AccountMeta,

        pub token_2022_program: AccountMeta,

        pub associated_token_program: AccountMeta,

        pub system_program: AccountMeta,

        pub event_authority: AccountMeta,

        pub program: AccountMeta,
    }

    /// Account pubkeys for RemoveLiquidity instruction
    #[derive(Debug, Clone)]
    pub struct RemoveLiquidityInstructionAccounts {
        pub pair: Pubkey,

        pub rate_model: Pubkey,

        pub futarchy_authority: Pubkey,

        pub token0_vault: Pubkey,

        pub token1_vault: Pubkey,

        pub user_token0_account: Pubkey,

        pub user_token1_account: Pubkey,

        pub token0_vault_mint: Pubkey,

        pub token1_vault_mint: Pubkey,

        pub lp_mint: Pubkey,

        pub user_lp_token_account: Pubkey,

        pub user: Pubkey,

        pub event_authority: Pubkey,

        pub program: Pubkey,
    }

    impl RemoveLiquidityInstructionAccounts {
        pub fn new(
            pair: Pubkey,

            rate_model: Pubkey,

            futarchy_authority: Pubkey,

            token0_vault: Pubkey,

            token1_vault: Pubkey,

            user_token0_account: Pubkey,

            user_token1_account: Pubkey,

            token0_vault_mint: Pubkey,

            token1_vault_mint: Pubkey,

            lp_mint: Pubkey,

            user_lp_token_account: Pubkey,

            user: Pubkey,

            event_authority: Pubkey,

            program: Pubkey,
        ) -> Self {
            Self {
                pair,

                rate_model,

                futarchy_authority,

                token0_vault,

                token1_vault,

                user_token0_account,

                user_token1_account,

                token0_vault_mint,

                token1_vault_mint,

                lp_mint,

                user_lp_token_account,

                user,

                event_authority,

                program,
            }
        }
    }

    /// Instruction data for RemoveLiquidity
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct RemoveLiquidityInstructionData {
        pub args: RemoveLiquidityArgs,
    }

    impl RemoveLiquidityInstructionData {
        pub fn new(args: RemoveLiquidityArgs) -> Self {
            Self { args }
        }
    }

    /// Implementation for RemoveLiquidityInstruction
    impl RemoveLiquidityInstruction {
        fn discriminator() -> [u8; 8] {
            [80u8, 85u8, 209u8, 72u8, 24u8, 206u8, 177u8, 108u8]
        }

        pub fn data(data: RemoveLiquidityInstructionData) -> Self {
            Self {
                accounts: RemoveLiquidityInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: RemoveLiquidityInstructionAccounts) -> Self {
            self.accounts.pair = AccountMeta::new(accounts.pair, false);

            self.accounts.rate_model = AccountMeta::new(accounts.rate_model, false);

            self.accounts.futarchy_authority =
                AccountMeta::new_readonly(accounts.futarchy_authority, false);

            self.accounts.token0_vault = AccountMeta::new(accounts.token0_vault, false);

            self.accounts.token1_vault = AccountMeta::new(accounts.token1_vault, false);

            self.accounts.user_token0_account =
                AccountMeta::new(accounts.user_token0_account, false);

            self.accounts.user_token1_account =
                AccountMeta::new(accounts.user_token1_account, false);

            self.accounts.token0_vault_mint =
                AccountMeta::new_readonly(accounts.token0_vault_mint, false);

            self.accounts.token1_vault_mint =
                AccountMeta::new_readonly(accounts.token1_vault_mint, false);

            self.accounts.lp_mint = AccountMeta::new(accounts.lp_mint, false);

            self.accounts.user_lp_token_account =
                AccountMeta::new(accounts.user_lp_token_account, false);

            self.accounts.user = AccountMeta::new(accounts.user, true);

            self.accounts.token_program = AccountMeta::new_readonly(
                pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
                false,
            );

            self.accounts.token_2022_program = AccountMeta::new_readonly(
                pubkey!("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),
                false,
            );

            self.accounts.associated_token_program = AccountMeta::new_readonly(
                pubkey!("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"),
                false,
            );

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self.accounts.event_authority =
                AccountMeta::new_readonly(accounts.event_authority, false);

            self.accounts.program = AccountMeta::new_readonly(accounts.program, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.pair.clone());

            metas.push(self.accounts.rate_model.clone());

            metas.push(self.accounts.futarchy_authority.clone());

            metas.push(self.accounts.token0_vault.clone());

            metas.push(self.accounts.token1_vault.clone());

            metas.push(self.accounts.user_token0_account.clone());

            metas.push(self.accounts.user_token1_account.clone());

            metas.push(self.accounts.token0_vault_mint.clone());

            metas.push(self.accounts.token1_vault_mint.clone());

            metas.push(self.accounts.lp_mint.clone());

            metas.push(self.accounts.user_lp_token_account.clone());

            metas.push(self.accounts.user.clone());

            metas.push(self.accounts.token_program.clone());

            metas.push(self.accounts.token_2022_program.clone());

            metas.push(self.accounts.associated_token_program.clone());

            metas.push(self.accounts.system_program.clone());

            metas.push(self.accounts.event_authority.clone());

            metas.push(self.accounts.program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: Repay
    // ....................................................................

    /// Main instruction struct for Repay
    pub struct RepayInstruction {
        pub accounts: RepayInstructionAccountMetas,
        pub data: RepayInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for Repay instruction
    #[derive(Debug, Clone, Default)]
    pub struct RepayInstructionAccountMetas {
        pub pair: AccountMeta,

        pub user_position: AccountMeta,

        pub rate_model: AccountMeta,

        pub futarchy_authority: AccountMeta,

        pub token_vault: AccountMeta,

        pub user_token_account: AccountMeta,

        pub vault_token_mint: AccountMeta,

        pub user: AccountMeta,

        pub token_program: AccountMeta,

        pub token_2022_program: AccountMeta,

        pub system_program: AccountMeta,

        pub event_authority: AccountMeta,

        pub program: AccountMeta,
    }

    /// Account pubkeys for Repay instruction
    #[derive(Debug, Clone)]
    pub struct RepayInstructionAccounts {
        pub pair: Pubkey,

        pub user_position: Pubkey,

        pub rate_model: Pubkey,

        pub futarchy_authority: Pubkey,

        pub token_vault: Pubkey,

        pub user_token_account: Pubkey,

        pub vault_token_mint: Pubkey,

        pub user: Pubkey,

        pub event_authority: Pubkey,

        pub program: Pubkey,
    }

    impl RepayInstructionAccounts {
        pub fn new(
            pair: Pubkey,

            user_position: Pubkey,

            rate_model: Pubkey,

            futarchy_authority: Pubkey,

            token_vault: Pubkey,

            user_token_account: Pubkey,

            vault_token_mint: Pubkey,

            user: Pubkey,

            event_authority: Pubkey,

            program: Pubkey,
        ) -> Self {
            Self {
                pair,

                user_position,

                rate_model,

                futarchy_authority,

                token_vault,

                user_token_account,

                vault_token_mint,

                user,

                event_authority,

                program,
            }
        }
    }

    /// Instruction data for Repay
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct RepayInstructionData {
        pub args: AdjustPositionArgs,
    }

    impl RepayInstructionData {
        pub fn new(args: AdjustPositionArgs) -> Self {
            Self { args }
        }
    }

    /// Implementation for RepayInstruction
    impl RepayInstruction {
        fn discriminator() -> [u8; 8] {
            [234u8, 103u8, 67u8, 82u8, 208u8, 234u8, 219u8, 166u8]
        }

        pub fn data(data: RepayInstructionData) -> Self {
            Self {
                accounts: RepayInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: RepayInstructionAccounts) -> Self {
            self.accounts.pair = AccountMeta::new(accounts.pair, false);

            self.accounts.user_position = AccountMeta::new(accounts.user_position, false);

            self.accounts.rate_model = AccountMeta::new(accounts.rate_model, false);

            self.accounts.futarchy_authority =
                AccountMeta::new_readonly(accounts.futarchy_authority, false);

            self.accounts.token_vault = AccountMeta::new(accounts.token_vault, false);

            self.accounts.user_token_account = AccountMeta::new(accounts.user_token_account, false);

            self.accounts.vault_token_mint =
                AccountMeta::new_readonly(accounts.vault_token_mint, false);

            self.accounts.user = AccountMeta::new(accounts.user, true);

            self.accounts.token_program = AccountMeta::new_readonly(
                pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
                false,
            );

            self.accounts.token_2022_program = AccountMeta::new_readonly(
                pubkey!("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),
                false,
            );

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self.accounts.event_authority =
                AccountMeta::new_readonly(accounts.event_authority, false);

            self.accounts.program = AccountMeta::new_readonly(accounts.program, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.pair.clone());

            metas.push(self.accounts.user_position.clone());

            metas.push(self.accounts.rate_model.clone());

            metas.push(self.accounts.futarchy_authority.clone());

            metas.push(self.accounts.token_vault.clone());

            metas.push(self.accounts.user_token_account.clone());

            metas.push(self.accounts.vault_token_mint.clone());

            metas.push(self.accounts.user.clone());

            metas.push(self.accounts.token_program.clone());

            metas.push(self.accounts.token_2022_program.clone());

            metas.push(self.accounts.system_program.clone());

            metas.push(self.accounts.event_authority.clone());

            metas.push(self.accounts.program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: Swap
    // ....................................................................

    /// Main instruction struct for Swap
    pub struct SwapInstruction {
        pub accounts: SwapInstructionAccountMetas,
        pub data: SwapInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for Swap instruction
    #[derive(Debug, Clone, Default)]
    pub struct SwapInstructionAccountMetas {
        pub pair: AccountMeta,

        pub rate_model: AccountMeta,

        pub futarchy_authority: AccountMeta,

        pub token_in_vault: AccountMeta,

        pub token_out_vault: AccountMeta,

        pub user_token_in_account: AccountMeta,

        pub user_token_out_account: AccountMeta,

        pub token_in_mint: AccountMeta,

        pub token_out_mint: AccountMeta,

        pub authority_token_in_account: AccountMeta,

        pub user: AccountMeta,

        pub token_program: AccountMeta,

        pub token_2022_program: AccountMeta,

        pub associated_token_program: AccountMeta,

        pub system_program: AccountMeta,

        pub event_authority: AccountMeta,

        pub program: AccountMeta,
    }

    /// Account pubkeys for Swap instruction
    #[derive(Debug, Clone)]
    pub struct SwapInstructionAccounts {
        pub pair: Pubkey,

        pub rate_model: Pubkey,

        pub futarchy_authority: Pubkey,

        pub token_in_vault: Pubkey,

        pub token_out_vault: Pubkey,

        pub user_token_in_account: Pubkey,

        pub user_token_out_account: Pubkey,

        pub token_in_mint: Pubkey,

        pub token_out_mint: Pubkey,

        pub authority_token_in_account: Pubkey,

        pub user: Pubkey,

        pub event_authority: Pubkey,

        pub program: Pubkey,
    }

    impl SwapInstructionAccounts {
        pub fn new(
            pair: Pubkey,

            rate_model: Pubkey,

            futarchy_authority: Pubkey,

            token_in_vault: Pubkey,

            token_out_vault: Pubkey,

            user_token_in_account: Pubkey,

            user_token_out_account: Pubkey,

            token_in_mint: Pubkey,

            token_out_mint: Pubkey,

            authority_token_in_account: Pubkey,

            user: Pubkey,

            event_authority: Pubkey,

            program: Pubkey,
        ) -> Self {
            Self {
                pair,

                rate_model,

                futarchy_authority,

                token_in_vault,

                token_out_vault,

                user_token_in_account,

                user_token_out_account,

                token_in_mint,

                token_out_mint,

                authority_token_in_account,

                user,

                event_authority,

                program,
            }
        }
    }

    /// Instruction data for Swap
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct SwapInstructionData {
        pub args: SwapArgs,
    }

    impl SwapInstructionData {
        pub fn new(args: SwapArgs) -> Self {
            Self { args }
        }
    }

    /// Implementation for SwapInstruction
    impl SwapInstruction {
        fn discriminator() -> [u8; 8] {
            [248u8, 198u8, 158u8, 145u8, 225u8, 117u8, 135u8, 200u8]
        }

        pub fn data(data: SwapInstructionData) -> Self {
            Self {
                accounts: SwapInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: SwapInstructionAccounts) -> Self {
            self.accounts.pair = AccountMeta::new(accounts.pair, false);

            self.accounts.rate_model = AccountMeta::new(accounts.rate_model, false);

            self.accounts.futarchy_authority =
                AccountMeta::new_readonly(accounts.futarchy_authority, false);

            self.accounts.token_in_vault = AccountMeta::new(accounts.token_in_vault, false);

            self.accounts.token_out_vault = AccountMeta::new(accounts.token_out_vault, false);

            self.accounts.user_token_in_account =
                AccountMeta::new(accounts.user_token_in_account, false);

            self.accounts.user_token_out_account =
                AccountMeta::new(accounts.user_token_out_account, false);

            self.accounts.token_in_mint = AccountMeta::new_readonly(accounts.token_in_mint, false);

            self.accounts.token_out_mint =
                AccountMeta::new_readonly(accounts.token_out_mint, false);

            self.accounts.authority_token_in_account =
                AccountMeta::new(accounts.authority_token_in_account, false);

            self.accounts.user = AccountMeta::new(accounts.user, true);

            self.accounts.token_program = AccountMeta::new_readonly(
                pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
                false,
            );

            self.accounts.token_2022_program = AccountMeta::new_readonly(
                pubkey!("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),
                false,
            );

            self.accounts.associated_token_program = AccountMeta::new_readonly(
                pubkey!("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"),
                false,
            );

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self.accounts.event_authority =
                AccountMeta::new_readonly(accounts.event_authority, false);

            self.accounts.program = AccountMeta::new_readonly(accounts.program, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.pair.clone());

            metas.push(self.accounts.rate_model.clone());

            metas.push(self.accounts.futarchy_authority.clone());

            metas.push(self.accounts.token_in_vault.clone());

            metas.push(self.accounts.token_out_vault.clone());

            metas.push(self.accounts.user_token_in_account.clone());

            metas.push(self.accounts.user_token_out_account.clone());

            metas.push(self.accounts.token_in_mint.clone());

            metas.push(self.accounts.token_out_mint.clone());

            metas.push(self.accounts.authority_token_in_account.clone());

            metas.push(self.accounts.user.clone());

            metas.push(self.accounts.token_program.clone());

            metas.push(self.accounts.token_2022_program.clone());

            metas.push(self.accounts.associated_token_program.clone());

            metas.push(self.accounts.system_program.clone());

            metas.push(self.accounts.event_authority.clone());

            metas.push(self.accounts.program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: ViewPairData
    // ....................................................................

    /// Main instruction struct for ViewPairData
    pub struct ViewPairDataInstruction {
        pub accounts: ViewPairDataInstructionAccountMetas,
        pub data: ViewPairDataInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for ViewPairData instruction
    #[derive(Debug, Clone, Default)]
    pub struct ViewPairDataInstructionAccountMetas {
        pub pair: AccountMeta,

        pub rate_model: AccountMeta,

        pub futarchy_authority: AccountMeta,
    }

    /// Account pubkeys for ViewPairData instruction
    #[derive(Debug, Clone)]
    pub struct ViewPairDataInstructionAccounts {
        pub pair: Pubkey,

        pub rate_model: Pubkey,

        pub futarchy_authority: Pubkey,
    }

    impl ViewPairDataInstructionAccounts {
        pub fn new(pair: Pubkey, rate_model: Pubkey, futarchy_authority: Pubkey) -> Self {
            Self {
                pair,

                rate_model,

                futarchy_authority,
            }
        }
    }

    /// Instruction data for ViewPairData
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct ViewPairDataInstructionData {
        pub getter: PairViewKind,

        pub args: EmitValueArgs,
    }

    impl ViewPairDataInstructionData {
        pub fn new(getter: PairViewKind, args: EmitValueArgs) -> Self {
            Self { getter, args }
        }
    }

    /// Implementation for ViewPairDataInstruction
    impl ViewPairDataInstruction {
        fn discriminator() -> [u8; 8] {
            [30u8, 231u8, 169u8, 73u8, 19u8, 161u8, 44u8, 252u8]
        }

        pub fn data(data: ViewPairDataInstructionData) -> Self {
            Self {
                accounts: ViewPairDataInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: ViewPairDataInstructionAccounts) -> Self {
            self.accounts.pair = AccountMeta::new(accounts.pair, false);

            self.accounts.rate_model = AccountMeta::new_readonly(accounts.rate_model, false);

            self.accounts.futarchy_authority =
                AccountMeta::new_readonly(accounts.futarchy_authority, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.pair.clone());

            metas.push(self.accounts.rate_model.clone());

            metas.push(self.accounts.futarchy_authority.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: ViewUserPositionData
    // ....................................................................

    /// Main instruction struct for ViewUserPositionData
    pub struct ViewUserPositionDataInstruction {
        pub accounts: ViewUserPositionDataInstructionAccountMetas,
        pub data: ViewUserPositionDataInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for ViewUserPositionData instruction
    #[derive(Debug, Clone, Default)]
    pub struct ViewUserPositionDataInstructionAccountMetas {
        pub pair: AccountMeta,

        pub user_position: AccountMeta,

        pub rate_model: AccountMeta,

        pub futarchy_authority: AccountMeta,
    }

    /// Account pubkeys for ViewUserPositionData instruction
    #[derive(Debug, Clone)]
    pub struct ViewUserPositionDataInstructionAccounts {
        pub pair: Pubkey,

        pub user_position: Pubkey,

        pub rate_model: Pubkey,

        pub futarchy_authority: Pubkey,
    }

    impl ViewUserPositionDataInstructionAccounts {
        pub fn new(
            pair: Pubkey,

            user_position: Pubkey,

            rate_model: Pubkey,

            futarchy_authority: Pubkey,
        ) -> Self {
            Self {
                pair,

                user_position,

                rate_model,

                futarchy_authority,
            }
        }
    }

    /// Instruction data for ViewUserPositionData
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct ViewUserPositionDataInstructionData {
        pub getter: UserPositionViewKind,
    }

    impl ViewUserPositionDataInstructionData {
        pub fn new(getter: UserPositionViewKind) -> Self {
            Self { getter }
        }
    }

    /// Implementation for ViewUserPositionDataInstruction
    impl ViewUserPositionDataInstruction {
        fn discriminator() -> [u8; 8] {
            [203u8, 218u8, 173u8, 213u8, 43u8, 31u8, 211u8, 152u8]
        }

        pub fn data(data: ViewUserPositionDataInstructionData) -> Self {
            Self {
                accounts: ViewUserPositionDataInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: ViewUserPositionDataInstructionAccounts) -> Self {
            self.accounts.pair = AccountMeta::new(accounts.pair, false);

            self.accounts.user_position = AccountMeta::new(accounts.user_position, false);

            self.accounts.rate_model = AccountMeta::new_readonly(accounts.rate_model, false);

            self.accounts.futarchy_authority =
                AccountMeta::new_readonly(accounts.futarchy_authority, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.pair.clone());

            metas.push(self.accounts.user_position.clone());

            metas.push(self.accounts.rate_model.clone());

            metas.push(self.accounts.futarchy_authority.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ------------------------------------------------------------------------
    // Composite Accounts
    // ------------------------------------------------------------------------
}

// ============================================================================
// CUSTOM TYPES
// ============================================================================

/// Custom struct: AddLiquidityArgs
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct AddLiquidityArgs {
    pub amount0_in: u64,

    pub amount1_in: u64,

    pub min_liquidity_out: u64,
}

impl AddLiquidityArgs {
    pub fn new(amount0_in: u64, amount1_in: u64, min_liquidity_out: u64) -> Self {
        Self {
            amount0_in,

            amount1_in,

            min_liquidity_out,
        }
    }
}

/// Custom struct: AdjustCollateralEvent
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct AdjustCollateralEvent {
    pub amount0: i64,

    pub amount1: i64,

    pub metadata: EventMetadata,
}

impl AdjustCollateralEvent {
    pub fn new(amount0: i64, amount1: i64, metadata: EventMetadata) -> Self {
        Self {
            amount0,

            amount1,

            metadata,
        }
    }
}

/// Custom struct: AdjustDebtEvent
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct AdjustDebtEvent {
    pub amount0: i64,

    pub amount1: i64,

    pub metadata: EventMetadata,
}

impl AdjustDebtEvent {
    pub fn new(amount0: i64, amount1: i64, metadata: EventMetadata) -> Self {
        Self {
            amount0,

            amount1,

            metadata,
        }
    }
}

/// Custom struct: AdjustLiquidityEvent
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct AdjustLiquidityEvent {
    pub amount0: u64,

    pub amount1: u64,

    pub liquidity: u64,

    pub metadata: EventMetadata,
}

impl AdjustLiquidityEvent {
    pub fn new(amount0: u64, amount1: u64, liquidity: u64, metadata: EventMetadata) -> Self {
        Self {
            amount0,

            amount1,

            liquidity,

            metadata,
        }
    }
}

/// Custom struct: AdjustPositionArgs
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct AdjustPositionArgs {
    pub amount: u64,
}

impl AdjustPositionArgs {
    pub fn new(amount: u64) -> Self {
        Self { amount }
    }
}

/// Custom struct: BurnEvent
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct BurnEvent {
    pub amount0: u64,

    pub amount1: u64,

    pub liquidity: u64,

    pub metadata: EventMetadata,
}

impl BurnEvent {
    pub fn new(amount0: u64, amount1: u64, liquidity: u64, metadata: EventMetadata) -> Self {
        Self {
            amount0,

            amount1,

            liquidity,

            metadata,
        }
    }
}

/// Custom struct: ClaimProtocolFeesArgs
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct ClaimProtocolFeesArgs {
    pub amount0: u64,

    pub amount1: u64,
}

impl ClaimProtocolFeesArgs {
    pub fn new(amount0: u64, amount1: u64) -> Self {
        Self { amount0, amount1 }
    }
}

/// Custom struct: DistributeTokensArgs
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct DistributeTokensArgs {}

impl DistributeTokensArgs {
    pub fn new() -> Self {
        Self {}
    }
}

/// Custom struct: EmitValueArgs
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct EmitValueArgs {
    pub debt_amount: Option<u64>,

    pub collateral_amount: Option<u64>,

    pub collateral_token: Option<Pubkey>,
}

impl EmitValueArgs {
    pub fn new(
        debt_amount: Option<u64>,

        collateral_amount: Option<u64>,

        collateral_token: Option<Pubkey>,
    ) -> Self {
        Self {
            debt_amount,

            collateral_amount,

            collateral_token,
        }
    }
}

/// Custom struct: EventMetadata
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct EventMetadata {
    pub signer: Pubkey,

    pub pair: Pubkey,

    pub timestamp: i64,
}

impl EventMetadata {
    pub fn new(signer: Pubkey, pair: Pubkey, timestamp: i64) -> Self {
        Self {
            signer,

            pair,

            timestamp,
        }
    }
}

/// Custom struct: FlashloanArgs
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct FlashloanArgs {
    pub amount0: u64,

    pub amount1: u64,

    pub data: Vec<u8>,
}

impl FlashloanArgs {
    pub fn new(amount0: u64, amount1: u64, data: Vec<u8>) -> Self {
        Self {
            amount0,

            amount1,

            data,
        }
    }
}

/// Custom struct: FlashloanEvent
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct FlashloanEvent {
    pub amount0: u64,

    pub amount1: u64,

    pub fee0: u64,

    pub fee1: u64,

    pub receiver: Pubkey,

    pub metadata: EventMetadata,
}

impl FlashloanEvent {
    pub fn new(
        amount0: u64,

        amount1: u64,

        fee0: u64,

        fee1: u64,

        receiver: Pubkey,

        metadata: EventMetadata,
    ) -> Self {
        Self {
            amount0,

            amount1,

            fee0,

            fee1,

            receiver,

            metadata,
        }
    }
}

/// Custom struct: FutarchyAuthority
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct FutarchyAuthority {
    pub version: u8,

    pub authority: Pubkey,

    pub recipients: RevenueRecipients,

    pub revenue_share: RevenueShare,

    pub revenue_distribution: RevenueDistribution,

    pub bump: u8,
}

impl FutarchyAuthority {
    pub fn new(
        version: u8,

        authority: Pubkey,

        recipients: RevenueRecipients,

        revenue_share: RevenueShare,

        revenue_distribution: RevenueDistribution,

        bump: u8,
    ) -> Self {
        Self {
            version,

            authority,

            recipients,

            revenue_share,

            revenue_distribution,

            bump,
        }
    }
}

/// Custom struct: InitFutarchyAuthorityArgs
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct InitFutarchyAuthorityArgs {
    pub authority: Pubkey,

    pub swap_bps: u16,

    pub interest_bps: u16,

    pub futarchy_treasury: Pubkey,

    pub futarchy_treasury_bps: u16,

    pub buybacks_vault: Pubkey,

    pub buybacks_vault_bps: u16,

    pub team_treasury: Pubkey,

    pub team_treasury_bps: u16,
}

impl InitFutarchyAuthorityArgs {
    pub fn new(
        authority: Pubkey,

        swap_bps: u16,

        interest_bps: u16,

        futarchy_treasury: Pubkey,

        futarchy_treasury_bps: u16,

        buybacks_vault: Pubkey,

        buybacks_vault_bps: u16,

        team_treasury: Pubkey,

        team_treasury_bps: u16,
    ) -> Self {
        Self {
            authority,

            swap_bps,

            interest_bps,

            futarchy_treasury,

            futarchy_treasury_bps,

            buybacks_vault,

            buybacks_vault_bps,

            team_treasury,

            team_treasury_bps,
        }
    }
}

/// Custom struct: InitializeAndBootstrapArgs
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct InitializeAndBootstrapArgs {
    pub swap_fee_bps: u16,

    pub half_life: u64,

    pub fixed_cf_bps: Option<u16>,

    pub pair_nonce: [u8; 16],

    pub amount0_in: u64,

    pub amount1_in: u64,

    pub min_liquidity_out: u64,

    pub lp_name: String,

    pub lp_symbol: String,

    pub lp_uri: String,
}

impl InitializeAndBootstrapArgs {
    pub fn new(
        swap_fee_bps: u16,

        half_life: u64,

        fixed_cf_bps: Option<u16>,

        pair_nonce: [u8; 16],

        amount0_in: u64,

        amount1_in: u64,

        min_liquidity_out: u64,

        lp_name: String,

        lp_symbol: String,

        lp_uri: String,
    ) -> Self {
        Self {
            swap_fee_bps,

            half_life,

            fixed_cf_bps,

            pair_nonce,

            amount0_in,

            amount1_in,

            min_liquidity_out,

            lp_name,

            lp_symbol,

            lp_uri,
        }
    }
}

/// Custom struct: MintEvent
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct MintEvent {
    pub amount0: u64,

    pub amount1: u64,

    pub liquidity: u64,

    pub metadata: EventMetadata,
}

impl MintEvent {
    pub fn new(amount0: u64, amount1: u64, liquidity: u64, metadata: EventMetadata) -> Self {
        Self {
            amount0,

            amount1,

            liquidity,

            metadata,
        }
    }
}

/// Custom struct: Pair
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct Pair {
    pub token0: Pubkey,

    pub token1: Pubkey,

    pub lp_mint: Pubkey,

    pub token0_decimals: u8,

    pub token1_decimals: u8,

    pub rate_model: Pubkey,

    pub swap_fee_bps: u16,

    pub half_life: u64,

    pub fixed_cf_bps: Option<u16>,

    pub reserve0: u64,

    pub reserve1: u64,

    pub protocol_revenue_reserve0: u64,

    pub protocol_revenue_reserve1: u64,

    pub last_price0_ema: u64,

    pub last_price1_ema: u64,

    pub last_update: i64,

    pub last_rate0: u64,

    pub last_rate1: u64,

    pub total_debt0: u64,

    pub total_debt1: u64,

    pub total_debt0_shares: u64,

    pub total_debt1_shares: u64,

    pub total_supply: u64,

    pub total_collateral0: u64,

    pub total_collateral1: u64,

    pub pair_nonce: [u8; 16],

    pub bump: u8,
}

impl Pair {
    pub fn new(
        token0: Pubkey,

        token1: Pubkey,

        lp_mint: Pubkey,

        token0_decimals: u8,

        token1_decimals: u8,

        rate_model: Pubkey,

        swap_fee_bps: u16,

        half_life: u64,

        fixed_cf_bps: Option<u16>,

        reserve0: u64,

        reserve1: u64,

        protocol_revenue_reserve0: u64,

        protocol_revenue_reserve1: u64,

        last_price0_ema: u64,

        last_price1_ema: u64,

        last_update: i64,

        last_rate0: u64,

        last_rate1: u64,

        total_debt0: u64,

        total_debt1: u64,

        total_debt0_shares: u64,

        total_debt1_shares: u64,

        total_supply: u64,

        total_collateral0: u64,

        total_collateral1: u64,

        pair_nonce: [u8; 16],

        bump: u8,
    ) -> Self {
        Self {
            token0,

            token1,

            lp_mint,

            token0_decimals,

            token1_decimals,

            rate_model,

            swap_fee_bps,

            half_life,

            fixed_cf_bps,

            reserve0,

            reserve1,

            protocol_revenue_reserve0,

            protocol_revenue_reserve1,

            last_price0_ema,

            last_price1_ema,

            last_update,

            last_rate0,

            last_rate1,

            total_debt0,

            total_debt1,

            total_debt0_shares,

            total_debt1_shares,

            total_supply,

            total_collateral0,

            total_collateral1,

            pair_nonce,

            bump,
        }
    }
}

/// Custom struct: PairCreatedEvent
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct PairCreatedEvent {
    pub token0: Pubkey,

    pub token1: Pubkey,

    pub metadata: EventMetadata,
}

impl PairCreatedEvent {
    pub fn new(token0: Pubkey, token1: Pubkey, metadata: EventMetadata) -> Self {
        Self {
            token0,

            token1,

            metadata,
        }
    }
}

/// Custom enum: PairViewKind
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone, PartialEq)]
pub enum PairViewKind {
    EmaPrice0Nad,

    EmaPrice1Nad,

    SpotPrice0Nad,

    SpotPrice1Nad,

    K,

    GetRates,

    GetBorrowLimitAndCfBpsForCollateral,
}

/// Custom struct: RateModel
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct RateModel {
    pub exp_rate: u64,

    pub target_util_start: u64,

    pub target_util_end: u64,
}

impl RateModel {
    pub fn new(exp_rate: u64, target_util_start: u64, target_util_end: u64) -> Self {
        Self {
            exp_rate,

            target_util_start,

            target_util_end,
        }
    }
}

/// Custom struct: RemoveLiquidityArgs
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct RemoveLiquidityArgs {
    pub liquidity_in: u64,

    pub min_amount0_out: u64,

    pub min_amount1_out: u64,
}

impl RemoveLiquidityArgs {
    pub fn new(liquidity_in: u64, min_amount0_out: u64, min_amount1_out: u64) -> Self {
        Self {
            liquidity_in,

            min_amount0_out,

            min_amount1_out,
        }
    }
}

/// Custom struct: RevenueDistribution
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct RevenueDistribution {
    pub futarchy_treasury_bps: u16,

    pub buybacks_vault_bps: u16,

    pub team_treasury_bps: u16,
}

impl RevenueDistribution {
    pub fn new(
        futarchy_treasury_bps: u16,

        buybacks_vault_bps: u16,

        team_treasury_bps: u16,
    ) -> Self {
        Self {
            futarchy_treasury_bps,

            buybacks_vault_bps,

            team_treasury_bps,
        }
    }
}

/// Custom struct: RevenueRecipients
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct RevenueRecipients {
    pub futarchy_treasury: Pubkey,

    pub buybacks_vault: Pubkey,

    pub team_treasury: Pubkey,
}

impl RevenueRecipients {
    pub fn new(futarchy_treasury: Pubkey, buybacks_vault: Pubkey, team_treasury: Pubkey) -> Self {
        Self {
            futarchy_treasury,

            buybacks_vault,

            team_treasury,
        }
    }
}

/// Custom struct: RevenueShare
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct RevenueShare {
    pub swap_bps: u16,

    pub interest_bps: u16,
}

impl RevenueShare {
    pub fn new(swap_bps: u16, interest_bps: u16) -> Self {
        Self {
            swap_bps,

            interest_bps,
        }
    }
}

/// Custom struct: SwapArgs
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct SwapArgs {
    pub amount_in: u64,

    pub min_amount_out: u64,
}

impl SwapArgs {
    pub fn new(amount_in: u64, min_amount_out: u64) -> Self {
        Self {
            amount_in,

            min_amount_out,
        }
    }
}

/// Custom struct: SwapEvent
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct SwapEvent {
    pub reserve0: u64,

    pub reserve1: u64,

    pub is_token0_in: bool,

    pub amount_in: u64,

    pub amount_out: u64,

    pub amount_in_after_fee: u64,

    pub metadata: EventMetadata,
}

impl SwapEvent {
    pub fn new(
        reserve0: u64,

        reserve1: u64,

        is_token0_in: bool,

        amount_in: u64,

        amount_out: u64,

        amount_in_after_fee: u64,

        metadata: EventMetadata,
    ) -> Self {
        Self {
            reserve0,

            reserve1,

            is_token0_in,

            amount_in,

            amount_out,

            amount_in_after_fee,

            metadata,
        }
    }
}

/// Custom struct: UpdatePairEvent
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct UpdatePairEvent {
    pub price0_ema: u64,

    pub price1_ema: u64,

    pub rate0: u64,

    pub rate1: u64,

    pub accrued_interest0: u128,

    pub accrued_interest1: u128,

    pub protocol_revenue_reserve0: u64,

    pub protocol_revenue_reserve1: u64,

    pub reserve0_after_interest: u64,

    pub reserve1_after_interest: u64,

    pub metadata: EventMetadata,
}

impl UpdatePairEvent {
    pub fn new(
        price0_ema: u64,

        price1_ema: u64,

        rate0: u64,

        rate1: u64,

        accrued_interest0: u128,

        accrued_interest1: u128,

        protocol_revenue_reserve0: u64,

        protocol_revenue_reserve1: u64,

        reserve0_after_interest: u64,

        reserve1_after_interest: u64,

        metadata: EventMetadata,
    ) -> Self {
        Self {
            price0_ema,

            price1_ema,

            rate0,

            rate1,

            accrued_interest0,

            accrued_interest1,

            protocol_revenue_reserve0,

            protocol_revenue_reserve1,

            reserve0_after_interest,

            reserve1_after_interest,

            metadata,
        }
    }
}

/// Custom struct: UserPosition
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct UserPosition {
    pub owner: Pubkey,

    pub pair: Pubkey,

    pub collateral0_applied_min_cf_bps: u16,

    pub collateral1_applied_min_cf_bps: u16,

    pub collateral0: u64,

    pub collateral1: u64,

    pub debt0_shares: u64,

    pub debt1_shares: u64,

    pub bump: u8,
}

impl UserPosition {
    pub fn new(
        owner: Pubkey,

        pair: Pubkey,

        collateral0_applied_min_cf_bps: u16,

        collateral1_applied_min_cf_bps: u16,

        collateral0: u64,

        collateral1: u64,

        debt0_shares: u64,

        debt1_shares: u64,

        bump: u8,
    ) -> Self {
        Self {
            owner,

            pair,

            collateral0_applied_min_cf_bps,

            collateral1_applied_min_cf_bps,

            collateral0,

            collateral1,

            debt0_shares,

            debt1_shares,

            bump,
        }
    }
}

/// Custom struct: UserPositionCreatedEvent
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct UserPositionCreatedEvent {
    pub position: Pubkey,

    pub metadata: EventMetadata,
}

impl UserPositionCreatedEvent {
    pub fn new(position: Pubkey, metadata: EventMetadata) -> Self {
        Self { position, metadata }
    }
}

/// Custom struct: UserPositionLiquidatedEvent
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct UserPositionLiquidatedEvent {
    pub position: Pubkey,

    pub liquidator: Pubkey,

    pub collateral0_liquidated: u64,

    pub collateral1_liquidated: u64,

    pub debt0_liquidated: u64,

    pub debt1_liquidated: u64,

    pub collateral_price: u64,

    pub shortfall: u128,

    pub liquidation_bonus_applied: u64,

    pub k0: u128,

    pub k1: u128,

    pub metadata: EventMetadata,
}

impl UserPositionLiquidatedEvent {
    pub fn new(
        position: Pubkey,

        liquidator: Pubkey,

        collateral0_liquidated: u64,

        collateral1_liquidated: u64,

        debt0_liquidated: u64,

        debt1_liquidated: u64,

        collateral_price: u64,

        shortfall: u128,

        liquidation_bonus_applied: u64,

        k0: u128,

        k1: u128,

        metadata: EventMetadata,
    ) -> Self {
        Self {
            position,

            liquidator,

            collateral0_liquidated,

            collateral1_liquidated,

            debt0_liquidated,

            debt1_liquidated,

            collateral_price,

            shortfall,

            liquidation_bonus_applied,

            k0,

            k1,

            metadata,
        }
    }
}

/// Custom struct: UserPositionUpdatedEvent
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct UserPositionUpdatedEvent {
    pub position: Pubkey,

    pub collateral0: u64,

    pub collateral1: u64,

    pub debt0_shares: u64,

    pub debt1_shares: u64,

    pub collateral0_applied_min_cf_bps: u16,

    pub collateral1_applied_min_cf_bps: u16,

    pub metadata: EventMetadata,
}

impl UserPositionUpdatedEvent {
    pub fn new(
        position: Pubkey,

        collateral0: u64,

        collateral1: u64,

        debt0_shares: u64,

        debt1_shares: u64,

        collateral0_applied_min_cf_bps: u16,

        collateral1_applied_min_cf_bps: u16,

        metadata: EventMetadata,
    ) -> Self {
        Self {
            position,

            collateral0,

            collateral1,

            debt0_shares,

            debt1_shares,

            collateral0_applied_min_cf_bps,

            collateral1_applied_min_cf_bps,

            metadata,
        }
    }
}

/// Custom enum: UserPositionViewKind
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub enum UserPositionViewKind {
    UserBorrowingPower,

    UserAppliedCollateralFactorBps,

    UserLiquidationCollateralFactorBps,

    UserDebtUtilizationBps,

    UserLiquidationPrice,

    UserDebtWithInterest,
}

// ============================================================================
// END OF GENERATED FILE
// ============================================================================
